/*
 * generated by Xtext
 */
package com.incquerylabs.uml.ralf.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ArithmeticExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.AssignmentExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.AssociationAccessExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.BitStringUnaryExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Block;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.BooleanLiteralExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.BooleanUnaryExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.BreakStatement;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.CastExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ClassExtentExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ClassificationExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ClassifyStatement;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ConcurrentClauses;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ConditionalLogicalExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ConditionalTestExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.DoStatement;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ElementCollectionExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.EmptyStatement;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.EqualityExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ExpressionList;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ExpressionStatement;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.FeatureInvocationExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.FeatureLeftHandSide;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ForEachStatement;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ForStatement;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.IfStatement;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.InstanceCreationExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.IsolationExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.LinkOperationExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.LocalNameDeclarationStatement;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.LogicalExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.LoopVariable;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.NameExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.NameLeftHandSide;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.NamedExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.NamedTuple;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.NaturalLiteralExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.NonFinalClause;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.NullExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.NumericUnaryExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.PostfixExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.PrefixExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.PropertyAccessExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.QualifiedNameList;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.RealLiteralExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ReducedAlfLanguagePackage;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.RelationalExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ReturnStatement;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.SendSignalStatement;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.SequenceAccessExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ShiftExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Statements;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.StringLiteralExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.SuperInvocationExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.SwitchClause;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.SwitchStatement;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ThisExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.TypeDeclaration;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.UnboundedLiteralExpression;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Variable;
import com.incquerylabs.uml.ralf.reducedAlfLanguage.WhileStatement;
import com.incquerylabs.uml.ralf.services.ReducedAlfLanguageGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ReducedAlfLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ReducedAlfLanguageGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == ReducedAlfLanguagePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case ReducedAlfLanguagePackage.ARITHMETIC_EXPRESSION:
				sequence_AdditiveExpression_MultiplicativeExpression(context, (ArithmeticExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.ASSIGNMENT_EXPRESSION:
				sequence_AssignmentExpression(context, (AssignmentExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.ASSOCIATION_ACCESS_EXPRESSION:
				sequence_PrimaryExpression(context, (AssociationAccessExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.BIT_STRING_UNARY_EXPRESSION:
				sequence_BitStringUnaryExpression(context, (BitStringUnaryExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.BLOCK:
				if(context == grammarAccess.getBlockRule() ||
				   context == grammarAccess.getBlockStatementRule() ||
				   context == grammarAccess.getStatementRule()) {
					sequence_Block(context, (Block) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getNonEmptyStatementSequenceRule() ||
				   context == grammarAccess.getSwitchDefaultClauseRule()) {
					sequence_NonEmptyStatementSequence(context, (Block) semanticObject); 
					return; 
				}
				else break;
			case ReducedAlfLanguagePackage.BOOLEAN_LITERAL_EXPRESSION:
				sequence_BooleanLiteralExpression(context, (BooleanLiteralExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.BOOLEAN_UNARY_EXPRESSION:
				sequence_BooleanUnaryExpression(context, (BooleanUnaryExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.BREAK_STATEMENT:
				sequence_BreakStatement(context, (BreakStatement) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.CAST_EXPRESSION:
				sequence_CastExpression(context, (CastExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.CLASS_EXTENT_EXPRESSION:
				sequence_ClassExtentExpression(context, (ClassExtentExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.CLASSIFICATION_EXPRESSION:
				sequence_ClassificationExpression(context, (ClassificationExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.CLASSIFY_STATEMENT:
				sequence_ClassifyStatement(context, (ClassifyStatement) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.CONCURRENT_CLAUSES:
				sequence_ConcurrentClauses(context, (ConcurrentClauses) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.CONDITIONAL_LOGICAL_EXPRESSION:
				sequence_ConditionalAndExpression_ConditionalOrExpression(context, (ConditionalLogicalExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.CONDITIONAL_TEST_EXPRESSION:
				sequence_ConditionalExpression(context, (ConditionalTestExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.DO_STATEMENT:
				sequence_DoStatement(context, (DoStatement) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.ELEMENT_COLLECTION_EXPRESSION:
				sequence_CollectionLiteralExpression(context, (ElementCollectionExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.EMPTY_STATEMENT:
				sequence_EmptyStatement(context, (EmptyStatement) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.EQUALITY_EXPRESSION:
				sequence_EqualityExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.EXPRESSION_LIST:
				sequence_ExpressionList(context, (ExpressionList) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.EXPRESSION_STATEMENT:
				sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.FEATURE_INVOCATION_EXPRESSION:
				if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getArithmeticExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getLogicalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getBaseExpressionRule() ||
				   context == grammarAccess.getCastCompletionRule() ||
				   context == grammarAccess.getClassificationExpressionRule() ||
				   context == grammarAccess.getClassificationExpressionAccess().getClassificationExpressionOperandAction_1_0() ||
				   context == grammarAccess.getConditionalAndExpressionRule() ||
				   context == grammarAccess.getConditionalAndExpressionAccess().getConditionalLogicalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getConditionalExpressionRule() ||
				   context == grammarAccess.getConditionalExpressionAccess().getConditionalTestExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getConditionalOrExpressionRule() ||
				   context == grammarAccess.getConditionalOrExpressionAccess().getConditionalLogicalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getEqualityExpressionRule() ||
				   context == grammarAccess.getEqualityExpressionAccess().getEqualityExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getExclusiveOrExpressionRule() ||
				   context == grammarAccess.getExclusiveOrExpressionAccess().getLogicalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getInclusiveOrExpressionRule() ||
				   context == grammarAccess.getInclusiveOrExpressionAccess().getLogicalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getIndexRule() ||
				   context == grammarAccess.getInitializationExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getArithmeticExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getParenthesizedExpressionRule() ||
				   context == grammarAccess.getPostfixOrCastExpressionRule() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getPrimaryExpressionAccess().getAssociationAccessExpressionContextAction_1_2_0() ||
				   context == grammarAccess.getPrimaryExpressionAccess().getFeatureInvocationExpressionContextAction_1_0_0() ||
				   context == grammarAccess.getPrimaryExpressionAccess().getPropertyAccessExpressionContextAction_1_1_0() ||
				   context == grammarAccess.getPrimaryExpressionAccess().getSequenceAccessExpressionPrimaryAction_1_3_0() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getRelationalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getShiftExpressionRule() ||
				   context == grammarAccess.getShiftExpressionAccess().getShiftExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getSwitchCaseRule() ||
				   context == grammarAccess.getUnaryExpressionRule()) {
					sequence_PrimaryExpression_ThisExpression(context, (FeatureInvocationExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getThisExpressionRule()) {
					sequence_ThisExpression(context, (FeatureInvocationExpression) semanticObject); 
					return; 
				}
				else break;
			case ReducedAlfLanguagePackage.FEATURE_LEFT_HAND_SIDE:
				sequence_FeatureLeftHandSide(context, (FeatureLeftHandSide) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.FOR_EACH_STATEMENT:
				sequence_ForEachStatement(context, (ForEachStatement) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.INSTANCE_CREATION_EXPRESSION:
				if(context == grammarAccess.getInitializationExpressionRule()) {
					sequence_InitializationExpression_InstanceCreationOrSequenceConstructionExpression_InstanceInitializationExpression(context, (InstanceCreationExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getArithmeticExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getLogicalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getBaseExpressionRule() ||
				   context == grammarAccess.getCastCompletionRule() ||
				   context == grammarAccess.getClassificationExpressionRule() ||
				   context == grammarAccess.getClassificationExpressionAccess().getClassificationExpressionOperandAction_1_0() ||
				   context == grammarAccess.getConditionalAndExpressionRule() ||
				   context == grammarAccess.getConditionalAndExpressionAccess().getConditionalLogicalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getConditionalExpressionRule() ||
				   context == grammarAccess.getConditionalExpressionAccess().getConditionalTestExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getConditionalOrExpressionRule() ||
				   context == grammarAccess.getConditionalOrExpressionAccess().getConditionalLogicalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getEqualityExpressionRule() ||
				   context == grammarAccess.getEqualityExpressionAccess().getEqualityExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getExclusiveOrExpressionRule() ||
				   context == grammarAccess.getExclusiveOrExpressionAccess().getLogicalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getInclusiveOrExpressionRule() ||
				   context == grammarAccess.getInclusiveOrExpressionAccess().getLogicalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getIndexRule() ||
				   context == grammarAccess.getInstanceCreationOrSequenceConstructionExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getArithmeticExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getParenthesizedExpressionRule() ||
				   context == grammarAccess.getPostfixOrCastExpressionRule() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getPrimaryExpressionAccess().getAssociationAccessExpressionContextAction_1_2_0() ||
				   context == grammarAccess.getPrimaryExpressionAccess().getFeatureInvocationExpressionContextAction_1_0_0() ||
				   context == grammarAccess.getPrimaryExpressionAccess().getPropertyAccessExpressionContextAction_1_1_0() ||
				   context == grammarAccess.getPrimaryExpressionAccess().getSequenceAccessExpressionPrimaryAction_1_3_0() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getRelationalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getShiftExpressionRule() ||
				   context == grammarAccess.getShiftExpressionAccess().getShiftExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getSwitchCaseRule() ||
				   context == grammarAccess.getUnaryExpressionRule()) {
					sequence_InstanceCreationOrSequenceConstructionExpression(context, (InstanceCreationExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getInstanceInitializationExpressionRule()) {
					sequence_InstanceInitializationExpression(context, (InstanceCreationExpression) semanticObject); 
					return; 
				}
				else break;
			case ReducedAlfLanguagePackage.ISOLATION_EXPRESSION:
				sequence_IsolationExpression(context, (IsolationExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.LINK_OPERATION_EXPRESSION:
				sequence_LinkOperationExpression(context, (LinkOperationExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.LOCAL_NAME_DECLARATION_STATEMENT:
				sequence_LocalNameDeclarationStatement(context, (LocalNameDeclarationStatement) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.LOGICAL_EXPRESSION:
				sequence_AndExpression_ExclusiveOrExpression_InclusiveOrExpression(context, (LogicalExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.LOOP_VARIABLE:
				sequence_LoopVariableDefinition(context, (LoopVariable) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.NAME_EXPRESSION:
				sequence_NameExpression(context, (NameExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.NAME_LEFT_HAND_SIDE:
				sequence_NameLeftHandSide(context, (NameLeftHandSide) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.NAMED_EXPRESSION:
				sequence_NamedExpression(context, (NamedExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.NAMED_TUPLE:
				sequence_NamedTupleExpressionList(context, (NamedTuple) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.NATURAL_LITERAL_EXPRESSION:
				sequence_NaturalLiteralExpression(context, (NaturalLiteralExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.NON_FINAL_CLAUSE:
				sequence_NonFinalClause(context, (NonFinalClause) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.NULL_EXPRESSION:
				sequence_NullExpression(context, (NullExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.NUMERIC_UNARY_EXPRESSION:
				sequence_NumericUnaryExpression(context, (NumericUnaryExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.POSTFIX_EXPRESSION:
				sequence_PostfixExpression(context, (PostfixExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.PREFIX_EXPRESSION:
				sequence_PrefixExpression(context, (PrefixExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.PROPERTY_ACCESS_EXPRESSION:
				if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getArithmeticExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getLogicalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getBaseExpressionRule() ||
				   context == grammarAccess.getCastCompletionRule() ||
				   context == grammarAccess.getClassificationExpressionRule() ||
				   context == grammarAccess.getClassificationExpressionAccess().getClassificationExpressionOperandAction_1_0() ||
				   context == grammarAccess.getConditionalAndExpressionRule() ||
				   context == grammarAccess.getConditionalAndExpressionAccess().getConditionalLogicalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getConditionalExpressionRule() ||
				   context == grammarAccess.getConditionalExpressionAccess().getConditionalTestExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getConditionalOrExpressionRule() ||
				   context == grammarAccess.getConditionalOrExpressionAccess().getConditionalLogicalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getEqualityExpressionRule() ||
				   context == grammarAccess.getEqualityExpressionAccess().getEqualityExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getExclusiveOrExpressionRule() ||
				   context == grammarAccess.getExclusiveOrExpressionAccess().getLogicalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getInclusiveOrExpressionRule() ||
				   context == grammarAccess.getInclusiveOrExpressionAccess().getLogicalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getIndexRule() ||
				   context == grammarAccess.getInitializationExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getArithmeticExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getParenthesizedExpressionRule() ||
				   context == grammarAccess.getPostfixOrCastExpressionRule() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getPrimaryExpressionAccess().getAssociationAccessExpressionContextAction_1_2_0() ||
				   context == grammarAccess.getPrimaryExpressionAccess().getFeatureInvocationExpressionContextAction_1_0_0() ||
				   context == grammarAccess.getPrimaryExpressionAccess().getPropertyAccessExpressionContextAction_1_1_0() ||
				   context == grammarAccess.getPrimaryExpressionAccess().getSequenceAccessExpressionPrimaryAction_1_3_0() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getRelationalExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getShiftExpressionRule() ||
				   context == grammarAccess.getShiftExpressionAccess().getShiftExpressionOperand1Action_1_0() ||
				   context == grammarAccess.getSwitchCaseRule() ||
				   context == grammarAccess.getUnaryExpressionRule()) {
					sequence_PrimaryExpression(context, (PropertyAccessExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPropertyAccessExpressionRule()) {
					sequence_PropertyAccessExpression(context, (PropertyAccessExpression) semanticObject); 
					return; 
				}
				else break;
			case ReducedAlfLanguagePackage.QUALIFIED_NAME_LIST:
				sequence_QualifiedNameList(context, (QualifiedNameList) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.REAL_LITERAL_EXPRESSION:
				sequence_RealLiteralExpression(context, (RealLiteralExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.RELATIONAL_EXPRESSION:
				sequence_RelationalExpression(context, (RelationalExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.SEND_SIGNAL_STATEMENT:
				sequence_SendSignalStatement(context, (SendSignalStatement) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.SEQUENCE_ACCESS_EXPRESSION:
				sequence_PrimaryExpression(context, (SequenceAccessExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.SHIFT_EXPRESSION:
				sequence_ShiftExpression(context, (ShiftExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.STATEMENTS:
				sequence_Statements(context, (Statements) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.STRING_LITERAL_EXPRESSION:
				sequence_StringLiteralExpression(context, (StringLiteralExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.SUPER_INVOCATION_EXPRESSION:
				sequence_SuperInvocationExpression(context, (SuperInvocationExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.SWITCH_CLAUSE:
				sequence_SwitchClause(context, (SwitchClause) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.SWITCH_STATEMENT:
				sequence_SwitchStatement(context, (SwitchStatement) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.THIS_EXPRESSION:
				sequence_ThisExpression(context, (ThisExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.TYPE_DECLARATION:
				sequence_TypeDeclaration(context, (TypeDeclaration) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.UNBOUNDED_LITERAL_EXPRESSION:
				sequence_UnboundedLiteralExpression(context, (UnboundedLiteralExpression) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.VARIABLE:
				sequence_VariableDeclaration(context, (Variable) semanticObject); 
				return; 
			case ReducedAlfLanguagePackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (
	 *         (operand1=AdditiveExpression_ArithmeticExpression_1_0 operator=AdditiveOperator operand2=MultiplicativeExpression) | 
	 *         (operand1=MultiplicativeExpression_ArithmeticExpression_1_0 operator=MultiplicativeOperator operand2=UnaryExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression(EObject context, ArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (operand1=ExclusiveOrExpression_LogicalExpression_1_0 operator='^' operand2=AndExpression) | 
	 *         (operand1=AndExpression_LogicalExpression_1_0 operator='&' operand2=EqualityExpression) | 
	 *         (operand1=InclusiveOrExpression_LogicalExpression_1_0 operator='|' operand2=ExclusiveOrExpression)
	 *     )
	 */
	protected void sequence_AndExpression_ExclusiveOrExpression_InclusiveOrExpression(EObject context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftHandSide=LeftHandSide operator=AssignmentOperator rightHandSide=Expression)
	 */
	protected void sequence_AssignmentExpression(EObject context, AssignmentExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__LEFT_HAND_SIDE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__LEFT_HAND_SIDE));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT_HAND_SIDE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT_HAND_SIDE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getLeftHandSideLeftHandSideParserRuleCall_0_0(), semanticObject.getLeftHandSide());
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getOperatorAssignmentOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getRightHandSideExpressionParserRuleCall_2_0(), semanticObject.getRightHandSide());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (operator='~' operand=UnaryExpression)
	 */
	protected void sequence_BitStringUnaryExpression(EObject context, BitStringUnaryExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.BIT_STRING_UNARY_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.BIT_STRING_UNARY_EXPRESSION__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.BIT_STRING_UNARY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.BIT_STRING_UNARY_EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBitStringUnaryExpressionAccess().getOperatorTildeKeyword_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getBitStringUnaryExpressionAccess().getOperandUnaryExpressionParserRuleCall_1_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (statement+=Statement*)
	 */
	protected void sequence_Block(EObject context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=BOOLEAN_VALUE
	 */
	protected void sequence_BooleanLiteralExpression(EObject context, BooleanLiteralExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.LITERAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.LITERAL_EXPRESSION__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBooleanLiteralExpressionAccess().getValueBOOLEAN_VALUETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (operator='!' operand=UnaryExpression)
	 */
	protected void sequence_BooleanUnaryExpression(EObject context, BooleanUnaryExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.BOOLEAN_UNARY_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.BOOLEAN_UNARY_EXPRESSION__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.BOOLEAN_UNARY_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.BOOLEAN_UNARY_EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBooleanUnaryExpressionAccess().getOperatorExclamationMarkKeyword_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getBooleanUnaryExpressionAccess().getOperandUnaryExpressionParserRuleCall_1_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {BreakStatement}
	 */
	protected void sequence_BreakStatement(EObject context, BreakStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=TypeDeclaration operand=CastCompletion)
	 */
	protected void sequence_CastExpression(EObject context, CastExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.CAST_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.CAST_EXPRESSION__TYPE));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.CAST_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.CAST_EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCastExpressionAccess().getTypeTypeDeclarationParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getCastExpressionAccess().getOperandCastCompletionParserRuleCall_3_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     class=[Class|QualifiedName]
	 */
	protected void sequence_ClassExtentExpression(EObject context, ClassExtentExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.CLASS_EXTENT_EXPRESSION__CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.CLASS_EXTENT_EXPRESSION__CLASS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getClassExtentExpressionAccess().getClassClassQualifiedNameParserRuleCall_0_0_1(), semanticObject.getClass_());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (operand=ClassificationExpression_ClassificationExpression_1_0 operator=ClassificationOperator type=[Class|QualifiedName])
	 */
	protected void sequence_ClassificationExpression(EObject context, ClassificationExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.CLASSIFICATION_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.CLASSIFICATION_EXPRESSION__OPERAND));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.CLASSIFICATION_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.CLASSIFICATION_EXPRESSION__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.CLASSIFICATION_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.CLASSIFICATION_EXPRESSION__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getClassificationExpressionAccess().getClassificationExpressionOperandAction_1_0(), semanticObject.getOperand());
		feeder.accept(grammarAccess.getClassificationExpressionAccess().getOperatorClassificationOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getClassificationExpressionAccess().getTypeClassQualifiedNameParserRuleCall_1_2_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         expression=Expression 
	 *         ((fromList=ClassificationFromClause toList=ClassificationToClause?) | (isReclassifyAll?=ReclassifyAllClause? toList=ClassificationToClause))
	 *     )
	 */
	protected void sequence_ClassifyStatement(EObject context, ClassifyStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((collectionType=CollectionType typeDeclaration=TypeDeclaration)? elements=ExpressionList?)
	 */
	protected void sequence_CollectionLiteralExpression(EObject context, ElementCollectionExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (clause+=NonFinalClause clause+=NonFinalClause*)
	 */
	protected void sequence_ConcurrentClauses(EObject context, ConcurrentClauses semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (operand1=ConditionalOrExpression_ConditionalLogicalExpression_1_0 operator='||' operand2=ConditionalAndExpression) | 
	 *         (operand1=ConditionalAndExpression_ConditionalLogicalExpression_1_0 operator='&&' operand2=InclusiveOrExpression)
	 *     )
	 */
	protected void sequence_ConditionalAndExpression_ConditionalOrExpression(EObject context, ConditionalLogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (operand1=ConditionalExpression_ConditionalTestExpression_1_0 operand2=Expression operand3=ConditionalExpression)
	 */
	protected void sequence_ConditionalExpression(EObject context, ConditionalTestExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.CONDITIONAL_TEST_EXPRESSION__OPERAND1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.CONDITIONAL_TEST_EXPRESSION__OPERAND1));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.CONDITIONAL_TEST_EXPRESSION__OPERAND2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.CONDITIONAL_TEST_EXPRESSION__OPERAND2));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.CONDITIONAL_TEST_EXPRESSION__OPERAND3) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.CONDITIONAL_TEST_EXPRESSION__OPERAND3));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getConditionalTestExpressionOperand1Action_1_0(), semanticObject.getOperand1());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getOperand2ExpressionParserRuleCall_1_2_0(), semanticObject.getOperand2());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getOperand3ConditionalExpressionParserRuleCall_1_4_0(), semanticObject.getOperand3());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (body=Block condition=Expression)
	 */
	protected void sequence_DoStatement(EObject context, DoStatement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.DO_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.DO_STATEMENT__BODY));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.DO_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.DO_STATEMENT__CONDITION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDoStatementAccess().getBodyBlockParserRuleCall_1_0(), semanticObject.getBody());
		feeder.accept(grammarAccess.getDoStatementAccess().getConditionExpressionParserRuleCall_4_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {EmptyStatement}
	 */
	protected void sequence_EmptyStatement(EObject context, EmptyStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (operand1=EqualityExpression_EqualityExpression_1_0 operator=EqualityOperator operand2=ClassificationExpression)
	 */
	protected void sequence_EqualityExpression(EObject context, EqualityExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.EQUALITY_EXPRESSION__OPERAND1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.EQUALITY_EXPRESSION__OPERAND1));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.EQUALITY_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.EQUALITY_EXPRESSION__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.EQUALITY_EXPRESSION__OPERAND2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.EQUALITY_EXPRESSION__OPERAND2));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEqualityExpressionAccess().getEqualityExpressionOperand1Action_1_0(), semanticObject.getOperand1());
		feeder.accept(grammarAccess.getEqualityExpressionAccess().getOperatorEqualityOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getEqualityExpressionAccess().getOperand2ClassificationExpressionParserRuleCall_1_2_0(), semanticObject.getOperand2());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((expressions+=Expression expressions+=Expression*)?)
	 */
	protected void sequence_ExpressionList(EObject context, ExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ExpressionStatement(EObject context, ExpressionStatement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.EXPRESSION_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.EXPRESSION_STATEMENT__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExpressionStatementAccess().getExpressionExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=PropertyAccessExpression
	 */
	protected void sequence_FeatureLeftHandSide(EObject context, FeatureLeftHandSide semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.FEATURE_LEFT_HAND_SIDE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.FEATURE_LEFT_HAND_SIDE__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFeatureLeftHandSideAccess().getExpressionPropertyAccessExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (variableDefinition=LoopVariableDefinition body=Block)
	 */
	protected void sequence_ForEachStatement(EObject context, ForEachStatement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.FOR_EACH_STATEMENT__VARIABLE_DEFINITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.FOR_EACH_STATEMENT__VARIABLE_DEFINITION));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.FOR_EACH_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.FOR_EACH_STATEMENT__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getForEachStatementAccess().getVariableDefinitionLoopVariableDefinitionParserRuleCall_2_0(), semanticObject.getVariableDefinition());
		feeder.accept(grammarAccess.getForEachStatementAccess().getBodyBlockParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (initialization=SimpleStatement condition=Expression update=SimpleStatement body=Block)
	 */
	protected void sequence_ForStatement(EObject context, ForStatement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.FOR_STATEMENT__INITIALIZATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.FOR_STATEMENT__INITIALIZATION));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.FOR_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.FOR_STATEMENT__CONDITION));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.FOR_STATEMENT__UPDATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.FOR_STATEMENT__UPDATE));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.FOR_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.FOR_STATEMENT__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getForStatementAccess().getInitializationSimpleStatementParserRuleCall_2_0(), semanticObject.getInitialization());
		feeder.accept(grammarAccess.getForStatementAccess().getConditionExpressionParserRuleCall_4_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getForStatementAccess().getUpdateSimpleStatementParserRuleCall_6_0(), semanticObject.getUpdate());
		feeder.accept(grammarAccess.getForStatementAccess().getBodyBlockParserRuleCall_8_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (nonFinalClauses+=ConcurrentClauses nonFinalClauses+=ConcurrentClauses* finalClause=Block?)
	 */
	protected void sequence_IfStatement(EObject context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((instance=[Classifier|QualifiedName] tuple=Tuple) | tuple=Tuple)
	 */
	protected void sequence_InitializationExpression_InstanceCreationOrSequenceConstructionExpression_InstanceInitializationExpression(EObject context, InstanceCreationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (instance=[Classifier|QualifiedName] tuple=Tuple)
	 */
	protected void sequence_InstanceCreationOrSequenceConstructionExpression(EObject context, InstanceCreationExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.INSTANCE_CREATION_EXPRESSION__INSTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.INSTANCE_CREATION_EXPRESSION__INSTANCE));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.INSTANCE_CREATION_EXPRESSION__TUPLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.INSTANCE_CREATION_EXPRESSION__TUPLE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInstanceCreationOrSequenceConstructionExpressionAccess().getInstanceClassifierQualifiedNameParserRuleCall_2_0_1(), semanticObject.getInstance());
		feeder.accept(grammarAccess.getInstanceCreationOrSequenceConstructionExpressionAccess().getTupleTupleParserRuleCall_3_0(), semanticObject.getTuple());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     tuple=Tuple
	 */
	protected void sequence_InstanceInitializationExpression(EObject context, InstanceCreationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (operator='$' operand=UnaryExpression)
	 */
	protected void sequence_IsolationExpression(EObject context, IsolationExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.ISOLATION_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.ISOLATION_EXPRESSION__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.ISOLATION_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.ISOLATION_EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIsolationExpressionAccess().getOperatorDollarSignKeyword_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getIsolationExpressionAccess().getOperandUnaryExpressionParserRuleCall_1_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (association=[Association|QualifiedName] operation=LinkOperation tuple=Tuple)
	 */
	protected void sequence_LinkOperationExpression(EObject context, LinkOperationExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.LINK_OPERATION_EXPRESSION__ASSOCIATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.LINK_OPERATION_EXPRESSION__ASSOCIATION));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.LINK_OPERATION_EXPRESSION__OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.LINK_OPERATION_EXPRESSION__OPERATION));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.LINK_OPERATION_EXPRESSION__TUPLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.LINK_OPERATION_EXPRESSION__TUPLE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLinkOperationExpressionAccess().getAssociationAssociationQualifiedNameParserRuleCall_0_0_1(), semanticObject.getAssociation());
		feeder.accept(grammarAccess.getLinkOperationExpressionAccess().getOperationLinkOperationEnumRuleCall_2_0(), semanticObject.getOperation());
		feeder.accept(grammarAccess.getLinkOperationExpressionAccess().getTupleTupleParserRuleCall_3_0(), semanticObject.getTuple());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (variable=VariableDeclaration expression=InitializationExpression)
	 */
	protected void sequence_LocalNameDeclarationStatement(EObject context, LocalNameDeclarationStatement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.LOCAL_NAME_DECLARATION_STATEMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.LOCAL_NAME_DECLARATION_STATEMENT__VARIABLE));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.LOCAL_NAME_DECLARATION_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.LOCAL_NAME_DECLARATION_STATEMENT__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLocalNameDeclarationStatementAccess().getVariableVariableDeclarationParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getLocalNameDeclarationStatementAccess().getExpressionInitializationExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((name=Name | (type=TypeDeclaration name=Name)) expression=Expression)
	 */
	protected void sequence_LoopVariableDefinition(EObject context, LoopVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     reference=[NamedElement|QualifiedName]
	 */
	protected void sequence_NameExpression(EObject context, NameExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.NAME_EXPRESSION__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.NAME_EXPRESSION__REFERENCE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNameExpressionAccess().getReferenceNamedElementQualifiedNameParserRuleCall_0_1(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (expression=NameExpression index=Index?)
	 */
	protected void sequence_NameLeftHandSide(EObject context, NameLeftHandSide semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=Name expression=Expression)
	 */
	protected void sequence_NamedExpression(EObject context, NamedExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.NAMED_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.NAMED_EXPRESSION__NAME));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.NAMED_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.NAMED_EXPRESSION__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNamedExpressionAccess().getNameNameParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNamedExpressionAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (expressions+=NamedExpression expressions+=NamedExpression*)
	 */
	protected void sequence_NamedTupleExpressionList(EObject context, NamedTuple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=NATURAL_VALUE
	 */
	protected void sequence_NaturalLiteralExpression(EObject context, NaturalLiteralExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.LITERAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.LITERAL_EXPRESSION__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNaturalLiteralExpressionAccess().getValueNATURAL_VALUETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     statement+=Statement+
	 */
	protected void sequence_NonEmptyStatementSequence(EObject context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (condition=Expression body=Block)
	 */
	protected void sequence_NonFinalClause(EObject context, NonFinalClause semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.NON_FINAL_CLAUSE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.NON_FINAL_CLAUSE__CONDITION));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.NON_FINAL_CLAUSE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.NON_FINAL_CLAUSE__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNonFinalClauseAccess().getConditionExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getNonFinalClauseAccess().getBodyBlockParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {NullExpression}
	 */
	protected void sequence_NullExpression(EObject context, NullExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (operator=NumericUnaryOperator (operand=PostfixOrCastExpression | operand=NonPostfixNonCastUnaryExpression)) | 
	 *         (operator=NumericUnaryOperator operand=PrefixExpression)
	 *     )
	 */
	protected void sequence_NumericUnaryExpression(EObject context, NumericUnaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (operand=LeftHandSide operator=AffixOperator)
	 */
	protected void sequence_PostfixExpression(EObject context, PostfixExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.POSTFIX_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.POSTFIX_EXPRESSION__OPERAND));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.POSTFIX_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.POSTFIX_EXPRESSION__OPERATOR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPostfixExpressionAccess().getOperandLeftHandSideParserRuleCall_1_0(), semanticObject.getOperand());
		feeder.accept(grammarAccess.getPostfixExpressionAccess().getOperatorAffixOperatorEnumRuleCall_2_0(), semanticObject.getOperator());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (operator=AffixOperator operand=LeftHandSide)
	 */
	protected void sequence_PrefixExpression(EObject context, PrefixExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.PREFIX_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.PREFIX_EXPRESSION__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.PREFIX_EXPRESSION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.PREFIX_EXPRESSION__OPERAND));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPrefixExpressionAccess().getOperatorAffixOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getPrefixExpressionAccess().getOperandLeftHandSideParserRuleCall_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (context=PrimaryExpression_AssociationAccessExpression_1_2_0 association=[Property|Name])
	 */
	protected void sequence_PrimaryExpression(EObject context, AssociationAccessExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.ASSOCIATION_ACCESS_EXPRESSION__CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.ASSOCIATION_ACCESS_EXPRESSION__CONTEXT));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.ASSOCIATION_ACCESS_EXPRESSION__ASSOCIATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.ASSOCIATION_ACCESS_EXPRESSION__ASSOCIATION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getAssociationAccessExpressionContextAction_1_2_0(), semanticObject.getContext());
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getAssociationPropertyNameParserRuleCall_1_2_2_0_1(), semanticObject.getAssociation());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (context=PrimaryExpression_PropertyAccessExpression_1_1_0 property=[Property|Name])
	 */
	protected void sequence_PrimaryExpression(EObject context, PropertyAccessExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.PROPERTY_ACCESS_EXPRESSION__CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.PROPERTY_ACCESS_EXPRESSION__CONTEXT));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.PROPERTY_ACCESS_EXPRESSION__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.PROPERTY_ACCESS_EXPRESSION__PROPERTY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getPropertyAccessExpressionContextAction_1_1_0(), semanticObject.getContext());
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getPropertyPropertyNameParserRuleCall_1_1_2_0_1(), semanticObject.getProperty());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (primary=PrimaryExpression_SequenceAccessExpression_1_3_0 index=Index)
	 */
	protected void sequence_PrimaryExpression(EObject context, SequenceAccessExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.SEQUENCE_ACCESS_EXPRESSION__PRIMARY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.SEQUENCE_ACCESS_EXPRESSION__PRIMARY));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.SEQUENCE_ACCESS_EXPRESSION__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.SEQUENCE_ACCESS_EXPRESSION__INDEX));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getSequenceAccessExpressionPrimaryAction_1_3_0(), semanticObject.getPrimary());
		feeder.accept(grammarAccess.getPrimaryExpressionAccess().getIndexIndexParserRuleCall_1_3_1_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((context=PrimaryExpression_FeatureInvocationExpression_1_0_0 isStatic?='::'? operation=[Operation|Name] parameters=Tuple) | tuple=Tuple)
	 */
	protected void sequence_PrimaryExpression_ThisExpression(EObject context, FeatureInvocationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (context=PrimaryExpression property=[Property|Name])
	 */
	protected void sequence_PropertyAccessExpression(EObject context, PropertyAccessExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.PROPERTY_ACCESS_EXPRESSION__CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.PROPERTY_ACCESS_EXPRESSION__CONTEXT));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.PROPERTY_ACCESS_EXPRESSION__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.PROPERTY_ACCESS_EXPRESSION__PROPERTY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPropertyAccessExpressionAccess().getContextPrimaryExpressionParserRuleCall_0_0(), semanticObject.getContext());
		feeder.accept(grammarAccess.getPropertyAccessExpressionAccess().getPropertyPropertyNameParserRuleCall_2_0_1(), semanticObject.getProperty());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name+=QualifiedName name+=QualifiedName*)
	 */
	protected void sequence_QualifiedNameList(EObject context, QualifiedNameList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=REAL_VALUE
	 */
	protected void sequence_RealLiteralExpression(EObject context, RealLiteralExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.LITERAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.LITERAL_EXPRESSION__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRealLiteralExpressionAccess().getValueREAL_VALUETerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (operand1=RelationalExpression_RelationalExpression_1_0 operator=RelationalOperator operand2=ShiftExpression)
	 */
	protected void sequence_RelationalExpression(EObject context, RelationalExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.RELATIONAL_EXPRESSION__OPERAND1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.RELATIONAL_EXPRESSION__OPERAND1));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.RELATIONAL_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.RELATIONAL_EXPRESSION__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.RELATIONAL_EXPRESSION__OPERAND2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.RELATIONAL_EXPRESSION__OPERAND2));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getRelationalExpressionOperand1Action_1_0(), semanticObject.getOperand1());
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getOperatorRelationalOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getOperand2ShiftExpressionParserRuleCall_1_2_0(), semanticObject.getOperand2());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (expression=Expression?)
	 */
	protected void sequence_ReturnStatement(EObject context, ReturnStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (signal=Expression target=Expression)
	 */
	protected void sequence_SendSignalStatement(EObject context, SendSignalStatement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.SEND_SIGNAL_STATEMENT__SIGNAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.SEND_SIGNAL_STATEMENT__SIGNAL));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.SEND_SIGNAL_STATEMENT__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.SEND_SIGNAL_STATEMENT__TARGET));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSendSignalStatementAccess().getSignalExpressionParserRuleCall_2_0(), semanticObject.getSignal());
		feeder.accept(grammarAccess.getSendSignalStatementAccess().getTargetExpressionParserRuleCall_4_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (operand1=ShiftExpression_ShiftExpression_1_0 operator=ShiftOperator operand2=AdditiveExpression)
	 */
	protected void sequence_ShiftExpression(EObject context, ShiftExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.SHIFT_EXPRESSION__OPERAND1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.SHIFT_EXPRESSION__OPERAND1));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.SHIFT_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.SHIFT_EXPRESSION__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.SHIFT_EXPRESSION__OPERAND2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.SHIFT_EXPRESSION__OPERAND2));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getShiftExpressionAccess().getShiftExpressionOperand1Action_1_0(), semanticObject.getOperand1());
		feeder.accept(grammarAccess.getShiftExpressionAccess().getOperatorShiftOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getShiftExpressionAccess().getOperand2AdditiveExpressionParserRuleCall_1_2_0(), semanticObject.getOperand2());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     statement+=Statement*
	 */
	protected void sequence_Statements(EObject context, Statements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteralExpression(EObject context, StringLiteralExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.LITERAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.LITERAL_EXPRESSION__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringLiteralExpressionAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (target=[Operation|QualifiedName]? tuple=Tuple)
	 */
	protected void sequence_SuperInvocationExpression(EObject context, SuperInvocationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (case+=SwitchCase case+=SwitchCase* block=NonEmptyStatementSequence)
	 */
	protected void sequence_SwitchClause(EObject context, SwitchClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expression=Expression nonDefaultClause+=SwitchClause* defaultClause=SwitchDefaultClause?)
	 */
	protected void sequence_SwitchStatement(EObject context, SwitchStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     tuple=Tuple
	 */
	protected void sequence_ThisExpression(EObject context, FeatureInvocationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {ThisExpression}
	 */
	protected void sequence_ThisExpression(EObject context, ThisExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type=[Type|QualifiedName]
	 */
	protected void sequence_TypeDeclaration(EObject context, TypeDeclaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.TYPE_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.TYPE_DECLARATION__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTypeDeclarationAccess().getTypeTypeQualifiedNameParserRuleCall_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value='*'
	 */
	protected void sequence_UnboundedLiteralExpression(EObject context, UnboundedLiteralExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.LITERAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.LITERAL_EXPRESSION__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getUnboundedLiteralExpressionAccess().getValueAsteriskKeyword_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=TypeDeclaration hasMultiplicity?=MultiplicityIndicator? name=Name)
	 */
	protected void sequence_VariableDeclaration(EObject context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (condition=Expression body=Block)
	 */
	protected void sequence_WhileStatement(EObject context, WhileStatement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.WHILE_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.WHILE_STATEMENT__CONDITION));
			if(transientValues.isValueTransient(semanticObject, ReducedAlfLanguagePackage.Literals.WHILE_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReducedAlfLanguagePackage.Literals.WHILE_STATEMENT__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWhileStatementAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getWhileStatementAccess().getBodyBlockParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
}
