/*
 * generated by Xtext
 */
package com.incquerylabs.uml.ralf.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class ReducedAlfLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class StatementsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statements");
		private final Assignment cStatementAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_0 = (RuleCall)cStatementAssignment.eContents().get(0);
		
		/// **
		// * TOP LEVEL ELEMENT
		// * / Statements:
		//	statement+=Statement*;
		@Override public ParserRule getRule() { return rule; }

		//statement+=Statement*
		public Assignment getStatementAssignment() { return cStatementAssignment; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_0() { return cStatementStatementParserRuleCall_0; }
	}

	public class NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUNRESTRICTED_NAMETerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// ***************
		// * NAMES        *
		// *************** / Name:
		//	ID | UNRESTRICTED_NAME;
		@Override public ParserRule getRule() { return rule; }

		//ID | UNRESTRICTED_NAME
		public Alternatives getAlternatives() { return cAlternatives; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//UNRESTRICTED_NAME
		public RuleCall getUNRESTRICTED_NAMETerminalRuleCall_1() { return cUNRESTRICTED_NAMETerminalRuleCall_1; }
	}

	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cColonColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cNameParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName:
		//	Name ("::" Name)*;
		@Override public ParserRule getRule() { return rule; }

		//Name ("::" Name)*
		public Group getGroup() { return cGroup; }

		//Name
		public RuleCall getNameParserRuleCall_0() { return cNameParserRuleCall_0; }

		//("::" Name)*
		public Group getGroup_1() { return cGroup_1; }

		//"::"
		public Keyword getColonColonKeyword_1_0() { return cColonColonKeyword_1_0; }

		//Name
		public RuleCall getNameParserRuleCall_1_1() { return cNameParserRuleCall_1_1; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAssignmentExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cConditionalExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// ***************
		// * EXPRESSIONS *
		// *************** / Expression:
		//	AssignmentExpression | ConditionalExpression;
		@Override public ParserRule getRule() { return rule; }

		//AssignmentExpression | ConditionalExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//AssignmentExpression
		public RuleCall getAssignmentExpressionParserRuleCall_0() { return cAssignmentExpressionParserRuleCall_0; }

		//ConditionalExpression
		public RuleCall getConditionalExpressionParserRuleCall_1() { return cConditionalExpressionParserRuleCall_1; }
	}

	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBaseExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cFeatureInvocationExpressionContextAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Alternatives cAlternatives_1_0_1 = (Alternatives)cGroup_1_0.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0_1_0 = (Keyword)cAlternatives_1_0_1.eContents().get(0);
		private final Assignment cIsStaticAssignment_1_0_1_1 = (Assignment)cAlternatives_1_0_1.eContents().get(1);
		private final Keyword cIsStaticColonColonKeyword_1_0_1_1_0 = (Keyword)cIsStaticAssignment_1_0_1_1.eContents().get(0);
		private final Assignment cOperationAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final CrossReference cOperationOperationCrossReference_1_0_2_0 = (CrossReference)cOperationAssignment_1_0_2.eContents().get(0);
		private final RuleCall cOperationOperationNameParserRuleCall_1_0_2_0_1 = (RuleCall)cOperationOperationCrossReference_1_0_2_0.eContents().get(1);
		private final Assignment cParametersAssignment_1_0_3 = (Assignment)cGroup_1_0.eContents().get(3);
		private final RuleCall cParametersTupleParserRuleCall_1_0_3_0 = (RuleCall)cParametersAssignment_1_0_3.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cPropertyAccessExpressionContextAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		private final Assignment cPropertyAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final CrossReference cPropertyPropertyCrossReference_1_1_2_0 = (CrossReference)cPropertyAssignment_1_1_2.eContents().get(0);
		private final RuleCall cPropertyPropertyNameParserRuleCall_1_1_2_0_1 = (RuleCall)cPropertyPropertyCrossReference_1_1_2_0.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Action cAssociationAccessExpressionContextAction_1_2_0 = (Action)cGroup_1_2.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_2_1 = (Keyword)cGroup_1_2.eContents().get(1);
		private final Assignment cAssociationAssignment_1_2_2 = (Assignment)cGroup_1_2.eContents().get(2);
		private final CrossReference cAssociationPropertyCrossReference_1_2_2_0 = (CrossReference)cAssociationAssignment_1_2_2.eContents().get(0);
		private final RuleCall cAssociationPropertyNameParserRuleCall_1_2_2_0_1 = (RuleCall)cAssociationPropertyCrossReference_1_2_2_0.eContents().get(1);
		private final Group cGroup_1_3 = (Group)cAlternatives_1.eContents().get(3);
		private final Action cSequenceAccessExpressionPrimaryAction_1_3_0 = (Action)cGroup_1_3.eContents().get(0);
		private final Assignment cIndexAssignment_1_3_1 = (Assignment)cGroup_1_3.eContents().get(1);
		private final RuleCall cIndexIndexParserRuleCall_1_3_1_0 = (RuleCall)cIndexAssignment_1_3_1.eContents().get(0);
		
		/// * PRIMARY EXPRESSIONS * / PrimaryExpression returns Expression:
		//	BaseExpression ({FeatureInvocationExpression.context=current} ("." | isStatic?="::") operation=[uml::Operation|Name]
		//	parameters=Tuple | {PropertyAccessExpression.context=current} "." property=[uml::Property|Name] |
		//	{AssociationAccessExpression.context=current} "->" association=[uml::Property|Name] | //    {ExtentOrExpression.nonNameExpression = current} '->' 
		//	//      ( {SequenceOperationExpression.primary = current} operation = [uml::Operation|QualifiedName] tuple = Tuple
		//	//      // CHANGE: Made SequenceExpansionExpression concrete.
		//	//      | {SequenceExpansionExpression.primary = current} operation = ID variable = Name '(' argument = Expression ')'
		//	//      ) | 
		//	{SequenceAccessExpression.primary=current} index=Index)*;
		@Override public ParserRule getRule() { return rule; }

		//BaseExpression ({FeatureInvocationExpression.context=current} ("." | isStatic?="::") operation=[uml::Operation|Name]
		//parameters=Tuple | {PropertyAccessExpression.context=current} "." property=[uml::Property|Name] |
		//{AssociationAccessExpression.context=current} "->" association=[uml::Property|Name] | //    {ExtentOrExpression.nonNameExpression = current} '->' 
		////      ( {SequenceOperationExpression.primary = current} operation = [uml::Operation|QualifiedName] tuple = Tuple
		////      // CHANGE: Made SequenceExpansionExpression concrete.
		////      | {SequenceExpansionExpression.primary = current} operation = ID variable = Name '(' argument = Expression ')'
		////      ) | 
		//{SequenceAccessExpression.primary=current} index=Index)*
		public Group getGroup() { return cGroup; }

		//BaseExpression
		public RuleCall getBaseExpressionParserRuleCall_0() { return cBaseExpressionParserRuleCall_0; }

		//({FeatureInvocationExpression.context=current} ("." | isStatic?="::") operation=[uml::Operation|Name] parameters=Tuple |
		//{PropertyAccessExpression.context=current} "." property=[uml::Property|Name] |
		//{AssociationAccessExpression.context=current} "->" association=[uml::Property|Name] | //    {ExtentOrExpression.nonNameExpression = current} '->' 
		////      ( {SequenceOperationExpression.primary = current} operation = [uml::Operation|QualifiedName] tuple = Tuple
		////      // CHANGE: Made SequenceExpansionExpression concrete.
		////      | {SequenceExpansionExpression.primary = current} operation = ID variable = Name '(' argument = Expression ')'
		////      ) | 
		//{SequenceAccessExpression.primary=current} index=Index)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//{FeatureInvocationExpression.context=current} ("." | isStatic?="::") operation=[uml::Operation|Name] parameters=Tuple
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{FeatureInvocationExpression.context=current}
		public Action getFeatureInvocationExpressionContextAction_1_0_0() { return cFeatureInvocationExpressionContextAction_1_0_0; }

		//"." | isStatic?="::"
		public Alternatives getAlternatives_1_0_1() { return cAlternatives_1_0_1; }

		//"."
		public Keyword getFullStopKeyword_1_0_1_0() { return cFullStopKeyword_1_0_1_0; }

		//isStatic?="::"
		public Assignment getIsStaticAssignment_1_0_1_1() { return cIsStaticAssignment_1_0_1_1; }

		//"::"
		public Keyword getIsStaticColonColonKeyword_1_0_1_1_0() { return cIsStaticColonColonKeyword_1_0_1_1_0; }

		//operation=[uml::Operation|Name]
		public Assignment getOperationAssignment_1_0_2() { return cOperationAssignment_1_0_2; }

		//[uml::Operation|Name]
		public CrossReference getOperationOperationCrossReference_1_0_2_0() { return cOperationOperationCrossReference_1_0_2_0; }

		//Name
		public RuleCall getOperationOperationNameParserRuleCall_1_0_2_0_1() { return cOperationOperationNameParserRuleCall_1_0_2_0_1; }

		//parameters=Tuple
		public Assignment getParametersAssignment_1_0_3() { return cParametersAssignment_1_0_3; }

		//Tuple
		public RuleCall getParametersTupleParserRuleCall_1_0_3_0() { return cParametersTupleParserRuleCall_1_0_3_0; }

		//{PropertyAccessExpression.context=current} "." property=[uml::Property|Name]
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{PropertyAccessExpression.context=current}
		public Action getPropertyAccessExpressionContextAction_1_1_0() { return cPropertyAccessExpressionContextAction_1_1_0; }

		//"."
		public Keyword getFullStopKeyword_1_1_1() { return cFullStopKeyword_1_1_1; }

		//property=[uml::Property|Name]
		public Assignment getPropertyAssignment_1_1_2() { return cPropertyAssignment_1_1_2; }

		//[uml::Property|Name]
		public CrossReference getPropertyPropertyCrossReference_1_1_2_0() { return cPropertyPropertyCrossReference_1_1_2_0; }

		//Name
		public RuleCall getPropertyPropertyNameParserRuleCall_1_1_2_0_1() { return cPropertyPropertyNameParserRuleCall_1_1_2_0_1; }

		//{AssociationAccessExpression.context=current} "->" association=[uml::Property|Name]
		public Group getGroup_1_2() { return cGroup_1_2; }

		//{AssociationAccessExpression.context=current}
		public Action getAssociationAccessExpressionContextAction_1_2_0() { return cAssociationAccessExpressionContextAction_1_2_0; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_2_1() { return cHyphenMinusGreaterThanSignKeyword_1_2_1; }

		//association=[uml::Property|Name]
		public Assignment getAssociationAssignment_1_2_2() { return cAssociationAssignment_1_2_2; }

		//[uml::Property|Name]
		public CrossReference getAssociationPropertyCrossReference_1_2_2_0() { return cAssociationPropertyCrossReference_1_2_2_0; }

		//Name
		public RuleCall getAssociationPropertyNameParserRuleCall_1_2_2_0_1() { return cAssociationPropertyNameParserRuleCall_1_2_2_0_1; }

		////    {ExtentOrExpression.nonNameExpression = current} '->' 
		////      ( {SequenceOperationExpression.primary = current} operation = [uml::Operation|QualifiedName] tuple = Tuple
		////      // CHANGE: Made SequenceExpansionExpression concrete.
		////      | {SequenceExpansionExpression.primary = current} operation = ID variable = Name '(' argument = Expression ')'
		////      ) | 
		//{SequenceAccessExpression.primary=current} index=Index
		public Group getGroup_1_3() { return cGroup_1_3; }

		////    {ExtentOrExpression.nonNameExpression = current} '->' 
		////      ( {SequenceOperationExpression.primary = current} operation = [uml::Operation|QualifiedName] tuple = Tuple
		////      // CHANGE: Made SequenceExpansionExpression concrete.
		////      | {SequenceExpansionExpression.primary = current} operation = ID variable = Name '(' argument = Expression ')'
		////      ) | 
		//{SequenceAccessExpression.primary=current}
		public Action getSequenceAccessExpressionPrimaryAction_1_3_0() { return cSequenceAccessExpressionPrimaryAction_1_3_0; }

		//index=Index
		public Assignment getIndexAssignment_1_3_1() { return cIndexAssignment_1_3_1; }

		//Index
		public RuleCall getIndexIndexParserRuleCall_1_3_1_0() { return cIndexIndexParserRuleCall_1_3_1_0; }
	}

	public class BaseExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BaseExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLiteralExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCollectionLiteralExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cThisExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSuperInvocationExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cInstanceCreationOrSequenceConstructionExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cClassExtentExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cLinkOperationExpressionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cNullExpressionParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cNameExpressionParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cParenthesizedExpressionParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		
		//BaseExpression returns Expression:
		//	LiteralExpression | CollectionLiteralExpression | ThisExpression | SuperInvocationExpression |
		//	InstanceCreationOrSequenceConstructionExpression | ClassExtentExpression | LinkOperationExpression | NullExpression | //  SequenceOperationOrReductionOrExpansionExpression |
		//	//    BehaviorInvocationExpression |
		//	NameExpression | ParenthesizedExpression;
		@Override public ParserRule getRule() { return rule; }

		//LiteralExpression | CollectionLiteralExpression | ThisExpression | SuperInvocationExpression |
		//InstanceCreationOrSequenceConstructionExpression | ClassExtentExpression | LinkOperationExpression | NullExpression | //  SequenceOperationOrReductionOrExpansionExpression |
		////    BehaviorInvocationExpression |
		//NameExpression | ParenthesizedExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//LiteralExpression
		public RuleCall getLiteralExpressionParserRuleCall_0() { return cLiteralExpressionParserRuleCall_0; }

		//CollectionLiteralExpression
		public RuleCall getCollectionLiteralExpressionParserRuleCall_1() { return cCollectionLiteralExpressionParserRuleCall_1; }

		//ThisExpression
		public RuleCall getThisExpressionParserRuleCall_2() { return cThisExpressionParserRuleCall_2; }

		//SuperInvocationExpression
		public RuleCall getSuperInvocationExpressionParserRuleCall_3() { return cSuperInvocationExpressionParserRuleCall_3; }

		//InstanceCreationOrSequenceConstructionExpression
		public RuleCall getInstanceCreationOrSequenceConstructionExpressionParserRuleCall_4() { return cInstanceCreationOrSequenceConstructionExpressionParserRuleCall_4; }

		//ClassExtentExpression
		public RuleCall getClassExtentExpressionParserRuleCall_5() { return cClassExtentExpressionParserRuleCall_5; }

		//LinkOperationExpression
		public RuleCall getLinkOperationExpressionParserRuleCall_6() { return cLinkOperationExpressionParserRuleCall_6; }

		//NullExpression
		public RuleCall getNullExpressionParserRuleCall_7() { return cNullExpressionParserRuleCall_7; }

		////  SequenceOperationOrReductionOrExpansionExpression |
		////    BehaviorInvocationExpression |
		//NameExpression
		public RuleCall getNameExpressionParserRuleCall_8() { return cNameExpressionParserRuleCall_8; }

		//ParenthesizedExpression
		public RuleCall getParenthesizedExpressionParserRuleCall_9() { return cParenthesizedExpressionParserRuleCall_9; }
	}

	public class LiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBooleanLiteralExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNaturalLiteralExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRealLiteralExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cUnboundedLiteralExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cStringLiteralExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		/// * LITERAL EXPRESSIONS * / LiteralExpression:
		//	BooleanLiteralExpression | NaturalLiteralExpression | RealLiteralExpression | UnboundedLiteralExpression |
		//	StringLiteralExpression;
		@Override public ParserRule getRule() { return rule; }

		//BooleanLiteralExpression | NaturalLiteralExpression | RealLiteralExpression | UnboundedLiteralExpression |
		//StringLiteralExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//BooleanLiteralExpression
		public RuleCall getBooleanLiteralExpressionParserRuleCall_0() { return cBooleanLiteralExpressionParserRuleCall_0; }

		//NaturalLiteralExpression
		public RuleCall getNaturalLiteralExpressionParserRuleCall_1() { return cNaturalLiteralExpressionParserRuleCall_1; }

		//RealLiteralExpression
		public RuleCall getRealLiteralExpressionParserRuleCall_2() { return cRealLiteralExpressionParserRuleCall_2; }

		//UnboundedLiteralExpression
		public RuleCall getUnboundedLiteralExpressionParserRuleCall_3() { return cUnboundedLiteralExpressionParserRuleCall_3; }

		//StringLiteralExpression
		public RuleCall getStringLiteralExpressionParserRuleCall_4() { return cStringLiteralExpressionParserRuleCall_4; }
	}

	public class BooleanLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiteralExpression");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBOOLEAN_VALUETerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//BooleanLiteralExpression:
		//	value=BOOLEAN_VALUE;
		@Override public ParserRule getRule() { return rule; }

		//value=BOOLEAN_VALUE
		public Assignment getValueAssignment() { return cValueAssignment; }

		//BOOLEAN_VALUE
		public RuleCall getValueBOOLEAN_VALUETerminalRuleCall_0() { return cValueBOOLEAN_VALUETerminalRuleCall_0; }
	}

	public class NaturalLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NaturalLiteralExpression");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueNATURAL_VALUETerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//NaturalLiteralExpression:
		//	value=NATURAL_VALUE;
		@Override public ParserRule getRule() { return rule; }

		//value=NATURAL_VALUE
		public Assignment getValueAssignment() { return cValueAssignment; }

		//NATURAL_VALUE
		public RuleCall getValueNATURAL_VALUETerminalRuleCall_0() { return cValueNATURAL_VALUETerminalRuleCall_0; }
	}

	public class RealLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RealLiteralExpression");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueREAL_VALUETerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//RealLiteralExpression:
		//	value=REAL_VALUE;
		@Override public ParserRule getRule() { return rule; }

		//value=REAL_VALUE
		public Assignment getValueAssignment() { return cValueAssignment; }

		//REAL_VALUE
		public RuleCall getValueREAL_VALUETerminalRuleCall_0() { return cValueREAL_VALUETerminalRuleCall_0; }
	}

	public class UnboundedLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnboundedLiteralExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUnboundedLiteralExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cValueAsteriskKeyword_1_0 = (Keyword)cValueAssignment_1.eContents().get(0);
		
		//UnboundedLiteralExpression:
		//	{UnboundedLiteralExpression} value="*";
		@Override public ParserRule getRule() { return rule; }

		//{UnboundedLiteralExpression} value="*"
		public Group getGroup() { return cGroup; }

		//{UnboundedLiteralExpression}
		public Action getUnboundedLiteralExpressionAction_0() { return cUnboundedLiteralExpressionAction_0; }

		//value="*"
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//"*"
		public Keyword getValueAsteriskKeyword_1_0() { return cValueAsteriskKeyword_1_0; }
	}

	public class StringLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringLiteralExpression");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringLiteralExpression:
		//	value=STRING;
		@Override public ParserRule getRule() { return rule; }

		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}

	public class NameExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NameExpression");
		private final Assignment cReferenceAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cReferenceNamedElementCrossReference_0 = (CrossReference)cReferenceAssignment.eContents().get(0);
		private final RuleCall cReferenceNamedElementQualifiedNameParserRuleCall_0_1 = (RuleCall)cReferenceNamedElementCrossReference_0.eContents().get(1);
		
		/// * Name EXPRESSIONS * / NameExpression:
		//	reference=[uml::NamedElement|QualifiedName];
		@Override public ParserRule getRule() { return rule; }

		//reference=[uml::NamedElement|QualifiedName]
		public Assignment getReferenceAssignment() { return cReferenceAssignment; }

		//[uml::NamedElement|QualifiedName]
		public CrossReference getReferenceNamedElementCrossReference_0() { return cReferenceNamedElementCrossReference_0; }

		//QualifiedName
		public RuleCall getReferenceNamedElementQualifiedNameParserRuleCall_0_1() { return cReferenceNamedElementQualifiedNameParserRuleCall_0_1; }
	}

	public class ThisExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ThisExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cFeatureInvocationExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cThisKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cTupleAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cTupleTupleParserRuleCall_0_2_0 = (RuleCall)cTupleAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cThisExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cThisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		/// * THIS EXPRESSIONS * / ThisExpression returns Expression:
		//	{FeatureInvocationExpression} "this" tuple=Tuple | {ThisExpression} "this";
		@Override public ParserRule getRule() { return rule; }

		//{FeatureInvocationExpression} "this" tuple=Tuple | {ThisExpression} "this"
		public Alternatives getAlternatives() { return cAlternatives; }

		//{FeatureInvocationExpression} "this" tuple=Tuple
		public Group getGroup_0() { return cGroup_0; }

		//{FeatureInvocationExpression}
		public Action getFeatureInvocationExpressionAction_0_0() { return cFeatureInvocationExpressionAction_0_0; }

		//"this"
		public Keyword getThisKeyword_0_1() { return cThisKeyword_0_1; }

		//tuple=Tuple
		public Assignment getTupleAssignment_0_2() { return cTupleAssignment_0_2; }

		//Tuple
		public RuleCall getTupleTupleParserRuleCall_0_2_0() { return cTupleTupleParserRuleCall_0_2_0; }

		//{ThisExpression} "this"
		public Group getGroup_1() { return cGroup_1; }

		//{ThisExpression}
		public Action getThisExpressionAction_1_0() { return cThisExpressionAction_1_0; }

		//"this"
		public Keyword getThisKeyword_1_1() { return cThisKeyword_1_1; }
	}

	public class ParenthesizedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParenthesizedExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		/// * PARENTHESIZED EXPRESSIONS * / ParenthesizedExpression returns Expression:
		//	"(" Expression ")";
		@Override public ParserRule getRule() { return rule; }

		//"(" Expression ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class PropertyAccessExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyAccessExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cContextAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cContextPrimaryExpressionParserRuleCall_0_0 = (RuleCall)cContextAssignment_0.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cPropertyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cPropertyPropertyCrossReference_2_0 = (CrossReference)cPropertyAssignment_2.eContents().get(0);
		private final RuleCall cPropertyPropertyNameParserRuleCall_2_0_1 = (RuleCall)cPropertyPropertyCrossReference_2_0.eContents().get(1);
		
		/// * PROPERTY ACCESS EXPRESSIONS * / // At this point in case of affix and postfix ++/-- operators, only variable names and properties can be used
		//// Property chaining is not supported at this time
		//// TODO: use primary expressions and filter using expression types
		//PropertyAccessExpression:
		//	context=PrimaryExpression "." property=[uml::Property|Name];
		@Override public ParserRule getRule() { return rule; }

		//context=PrimaryExpression "." property=[uml::Property|Name]
		public Group getGroup() { return cGroup; }

		//context=PrimaryExpression
		public Assignment getContextAssignment_0() { return cContextAssignment_0; }

		//PrimaryExpression
		public RuleCall getContextPrimaryExpressionParserRuleCall_0_0() { return cContextPrimaryExpressionParserRuleCall_0_0; }

		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }

		//property=[uml::Property|Name]
		public Assignment getPropertyAssignment_2() { return cPropertyAssignment_2; }

		//[uml::Property|Name]
		public CrossReference getPropertyPropertyCrossReference_2_0() { return cPropertyPropertyCrossReference_2_0; }

		//Name
		public RuleCall getPropertyPropertyNameParserRuleCall_2_0_1() { return cPropertyPropertyNameParserRuleCall_2_0_1; }
	}

	public class TupleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Tuple");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cExpressionListAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final RuleCall cNamedTupleExpressionListParserRuleCall_1_1_0 = (RuleCall)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cExpressionListParserRuleCall_1_1_1 = (RuleCall)cAlternatives_1_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		////FeatureReference :
		////  expression = PrimaryExpression // '.' nameBinding = NameBinding
		////;
		////FeatureTargetExpression returns Expression :
		////  NonNamePrimaryExpression | NameTargetExpression
		////;
		////
		////NameTargetExpression returns NameExpression :
		////  name = ColonQualifiedName
		////;
		/// * INVOCATION EXPRESSIONS * / //
		////BehaviorInvocationExpression :
		////  target = [uml::Behavior|QualifiedName] tuple = Tuple
		////;
		//Tuple:
		//	{ExpressionList} "(" ")" | "(" (NamedTupleExpressionList | ExpressionList) ")";
		@Override public ParserRule getRule() { return rule; }

		//{ExpressionList} "(" ")" | "(" (NamedTupleExpressionList | ExpressionList) ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//{ExpressionList} "(" ")"
		public Group getGroup_0() { return cGroup_0; }

		//{ExpressionList}
		public Action getExpressionListAction_0_0() { return cExpressionListAction_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_1() { return cLeftParenthesisKeyword_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//"(" (NamedTupleExpressionList | ExpressionList) ")"
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//NamedTupleExpressionList | ExpressionList
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//NamedTupleExpressionList
		public RuleCall getNamedTupleExpressionListParserRuleCall_1_1_0() { return cNamedTupleExpressionListParserRuleCall_1_1_0; }

		//ExpressionList
		public RuleCall getExpressionListParserRuleCall_1_1_1() { return cExpressionListParserRuleCall_1_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class ExpressionListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpressionList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cExpressionListAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cExpressionsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cExpressionsExpressionParserRuleCall_1_0_0 = (RuleCall)cExpressionsAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cExpressionsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cExpressionsExpressionParserRuleCall_1_1_1_0 = (RuleCall)cExpressionsAssignment_1_1_1.eContents().get(0);
		
		//ExpressionList:
		//	{ExpressionList} (expressions+=Expression ("," expressions+=Expression)*)?;
		@Override public ParserRule getRule() { return rule; }

		//{ExpressionList} (expressions+=Expression ("," expressions+=Expression)*)?
		public Group getGroup() { return cGroup; }

		//{ExpressionList}
		public Action getExpressionListAction_0() { return cExpressionListAction_0; }

		//(expressions+=Expression ("," expressions+=Expression)*)?
		public Group getGroup_1() { return cGroup_1; }

		//expressions+=Expression
		public Assignment getExpressionsAssignment_1_0() { return cExpressionsAssignment_1_0; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_1_0_0() { return cExpressionsExpressionParserRuleCall_1_0_0; }

		//("," expressions+=Expression)*
		public Group getGroup_1_1() { return cGroup_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }

		//expressions+=Expression
		public Assignment getExpressionsAssignment_1_1_1() { return cExpressionsAssignment_1_1_1; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_1_1_1_0() { return cExpressionsExpressionParserRuleCall_1_1_1_0; }
	}

	public class NamedTupleExpressionListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NamedTupleExpressionList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionsNamedExpressionParserRuleCall_0_0 = (RuleCall)cExpressionsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cExpressionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionsNamedExpressionParserRuleCall_1_1_0 = (RuleCall)cExpressionsAssignment_1_1.eContents().get(0);
		
		//NamedTupleExpressionList returns NamedTuple:
		//	expressions+=NamedExpression ("," expressions+=NamedExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//expressions+=NamedExpression ("," expressions+=NamedExpression)*
		public Group getGroup() { return cGroup; }

		//expressions+=NamedExpression
		public Assignment getExpressionsAssignment_0() { return cExpressionsAssignment_0; }

		//NamedExpression
		public RuleCall getExpressionsNamedExpressionParserRuleCall_0_0() { return cExpressionsNamedExpressionParserRuleCall_0_0; }

		//("," expressions+=NamedExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//expressions+=NamedExpression
		public Assignment getExpressionsAssignment_1_1() { return cExpressionsAssignment_1_1; }

		//NamedExpression
		public RuleCall getExpressionsNamedExpressionParserRuleCall_1_1_0() { return cExpressionsNamedExpressionParserRuleCall_1_1_0; }
	}

	public class NamedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NamedExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//NamedExpression:
		//	name=Name "=>" expression=Expression;
		@Override public ParserRule getRule() { return rule; }

		//name=Name "=>" expression=Expression
		public Group getGroup() { return cGroup; }

		//name=Name
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//Name
		public RuleCall getNameNameParserRuleCall_0_0() { return cNameNameParserRuleCall_0_0; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_1() { return cEqualsSignGreaterThanSignKeyword_1; }

		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
	}

	public class SuperInvocationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SuperInvocationExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSuperKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTargetAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final CrossReference cTargetOperationCrossReference_1_1_0 = (CrossReference)cTargetAssignment_1_1.eContents().get(0);
		private final RuleCall cTargetOperationQualifiedNameParserRuleCall_1_1_0_1 = (RuleCall)cTargetOperationCrossReference_1_1_0.eContents().get(1);
		private final Assignment cTupleAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTupleTupleParserRuleCall_2_0 = (RuleCall)cTupleAssignment_2.eContents().get(0);
		
		//SuperInvocationExpression:
		//	"super" ("." target=[uml::Operation|QualifiedName])? tuple=Tuple;
		@Override public ParserRule getRule() { return rule; }

		//"super" ("." target=[uml::Operation|QualifiedName])? tuple=Tuple
		public Group getGroup() { return cGroup; }

		//"super"
		public Keyword getSuperKeyword_0() { return cSuperKeyword_0; }

		//("." target=[uml::Operation|QualifiedName])?
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//target=[uml::Operation|QualifiedName]
		public Assignment getTargetAssignment_1_1() { return cTargetAssignment_1_1; }

		//[uml::Operation|QualifiedName]
		public CrossReference getTargetOperationCrossReference_1_1_0() { return cTargetOperationCrossReference_1_1_0; }

		//QualifiedName
		public RuleCall getTargetOperationQualifiedNameParserRuleCall_1_1_0_1() { return cTargetOperationQualifiedNameParserRuleCall_1_1_0_1; }

		//tuple=Tuple
		public Assignment getTupleAssignment_2() { return cTupleAssignment_2; }

		//Tuple
		public RuleCall getTupleTupleParserRuleCall_2_0() { return cTupleTupleParserRuleCall_2_0; }
	}

	public class InstanceCreationOrSequenceConstructionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InstanceCreationOrSequenceConstructionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cInstanceCreationExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNewKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cInstanceAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cInstanceClassifierCrossReference_2_0 = (CrossReference)cInstanceAssignment_2.eContents().get(0);
		private final RuleCall cInstanceClassifierQualifiedNameParserRuleCall_2_0_1 = (RuleCall)cInstanceClassifierCrossReference_2_0.eContents().get(1);
		private final Assignment cTupleAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTupleTupleParserRuleCall_3_0 = (RuleCall)cTupleAssignment_3.eContents().get(0);
		
		/// * INSTANCE CREATION EXPRESSIONS * / InstanceCreationOrSequenceConstructionExpression returns Expression:
		//	{InstanceCreationExpression} "new" instance=[uml::Classifier|QualifiedName] tuple=Tuple;
		@Override public ParserRule getRule() { return rule; }

		//{InstanceCreationExpression} "new" instance=[uml::Classifier|QualifiedName] tuple=Tuple
		public Group getGroup() { return cGroup; }

		//{InstanceCreationExpression}
		public Action getInstanceCreationExpressionAction_0() { return cInstanceCreationExpressionAction_0; }

		//"new"
		public Keyword getNewKeyword_1() { return cNewKeyword_1; }

		//instance=[uml::Classifier|QualifiedName]
		public Assignment getInstanceAssignment_2() { return cInstanceAssignment_2; }

		//[uml::Classifier|QualifiedName]
		public CrossReference getInstanceClassifierCrossReference_2_0() { return cInstanceClassifierCrossReference_2_0; }

		//QualifiedName
		public RuleCall getInstanceClassifierQualifiedNameParserRuleCall_2_0_1() { return cInstanceClassifierQualifiedNameParserRuleCall_2_0_1; }

		//tuple=Tuple
		public Assignment getTupleAssignment_3() { return cTupleAssignment_3; }

		//Tuple
		public RuleCall getTupleTupleParserRuleCall_3_0() { return cTupleTupleParserRuleCall_3_0; }
	}

	public class LinkOperationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LinkOperationExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAssociationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cAssociationAssociationCrossReference_0_0 = (CrossReference)cAssociationAssignment_0.eContents().get(0);
		private final RuleCall cAssociationAssociationQualifiedNameParserRuleCall_0_0_1 = (RuleCall)cAssociationAssociationCrossReference_0_0.eContents().get(1);
		private final Keyword cColonColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOperationAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperationLinkOperationEnumRuleCall_2_0 = (RuleCall)cOperationAssignment_2.eContents().get(0);
		private final Assignment cTupleAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTupleTupleParserRuleCall_3_0 = (RuleCall)cTupleAssignment_3.eContents().get(0);
		
		/// * LINK OPERATION EXPRESSIONS * / LinkOperationExpression:
		//	association=[uml::Association|QualifiedName] "::" operation=LinkOperation tuple=Tuple;
		@Override public ParserRule getRule() { return rule; }

		//association=[uml::Association|QualifiedName] "::" operation=LinkOperation tuple=Tuple
		public Group getGroup() { return cGroup; }

		//association=[uml::Association|QualifiedName]
		public Assignment getAssociationAssignment_0() { return cAssociationAssignment_0; }

		//[uml::Association|QualifiedName]
		public CrossReference getAssociationAssociationCrossReference_0_0() { return cAssociationAssociationCrossReference_0_0; }

		//QualifiedName
		public RuleCall getAssociationAssociationQualifiedNameParserRuleCall_0_0_1() { return cAssociationAssociationQualifiedNameParserRuleCall_0_0_1; }

		//"::"
		public Keyword getColonColonKeyword_1() { return cColonColonKeyword_1; }

		//operation=LinkOperation
		public Assignment getOperationAssignment_2() { return cOperationAssignment_2; }

		//LinkOperation
		public RuleCall getOperationLinkOperationEnumRuleCall_2_0() { return cOperationLinkOperationEnumRuleCall_2_0; }

		//tuple=Tuple
		public Assignment getTupleAssignment_3() { return cTupleAssignment_3; }

		//Tuple
		public RuleCall getTupleTupleParserRuleCall_3_0() { return cTupleTupleParserRuleCall_3_0; }
	}

	public class ClassExtentExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClassExtentExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cClassAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cClassClassCrossReference_0_0 = (CrossReference)cClassAssignment_0.eContents().get(0);
		private final RuleCall cClassClassQualifiedNameParserRuleCall_0_0_1 = (RuleCall)cClassClassCrossReference_0_0.eContents().get(1);
		private final Keyword cColonColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cInstancesKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		/// * CLASS EXTENT EXPRESSIONS * / ClassExtentExpression:
		//	class=[uml::Class|QualifiedName] "::" "instances" "(" ")";
		@Override public ParserRule getRule() { return rule; }

		//class=[uml::Class|QualifiedName] "::" "instances" "(" ")"
		public Group getGroup() { return cGroup; }

		//class=[uml::Class|QualifiedName]
		public Assignment getClassAssignment_0() { return cClassAssignment_0; }

		//[uml::Class|QualifiedName]
		public CrossReference getClassClassCrossReference_0_0() { return cClassClassCrossReference_0_0; }

		//QualifiedName
		public RuleCall getClassClassQualifiedNameParserRuleCall_0_0_1() { return cClassClassQualifiedNameParserRuleCall_0_0_1; }

		//"::"
		public Keyword getColonColonKeyword_1() { return cColonColonKeyword_1; }

		//"instances"
		public Keyword getInstancesKeyword_2() { return cInstancesKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class NullExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NullExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNullExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNullKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		/// * NULL EXPRESSION * / NullExpression:
		//	{NullExpression} "null";
		@Override public ParserRule getRule() { return rule; }

		//{NullExpression} "null"
		public Group getGroup() { return cGroup; }

		//{NullExpression}
		public Action getNullExpressionAction_0() { return cNullExpressionAction_0; }

		//"null"
		public Keyword getNullKeyword_1() { return cNullKeyword_1; }
	}

	public class CollectionLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CollectionLiteralExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cElementCollectionExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cCollectionTypeAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cCollectionTypeCollectionTypeEnumRuleCall_1_0_0 = (RuleCall)cCollectionTypeAssignment_1_0.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cTypeDeclarationAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cTypeDeclarationTypeDeclarationParserRuleCall_1_2_0 = (RuleCall)cTypeDeclarationAssignment_1_2.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cElementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cElementsExpressionListParserRuleCall_3_0 = (RuleCall)cElementsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		/// * SEQUENCE CONSTRUCTION EXPRESSIONS * / CollectionLiteralExpression: //    {RangeCollectionExpression}
		////    collectionType = CollectionType '<' typeDeclaration = TypeDeclaration '>' '{' ( range = SequenceRange)? '}' |
		//	{ElementCollectionExpression} (collectionType=CollectionType "<" typeDeclaration=TypeDeclaration ">")? "{"
		//	elements=ExpressionList? "}";
		@Override public ParserRule getRule() { return rule; }

		////    {RangeCollectionExpression}
		////    collectionType = CollectionType '<' typeDeclaration = TypeDeclaration '>' '{' ( range = SequenceRange)? '}' |
		//{ElementCollectionExpression} (collectionType=CollectionType "<" typeDeclaration=TypeDeclaration ">")? "{"
		//elements=ExpressionList? "}"
		public Group getGroup() { return cGroup; }

		////    {RangeCollectionExpression}
		////    collectionType = CollectionType '<' typeDeclaration = TypeDeclaration '>' '{' ( range = SequenceRange)? '}' |
		//{ElementCollectionExpression}
		public Action getElementCollectionExpressionAction_0() { return cElementCollectionExpressionAction_0; }

		//(collectionType=CollectionType "<" typeDeclaration=TypeDeclaration ">")?
		public Group getGroup_1() { return cGroup_1; }

		//collectionType=CollectionType
		public Assignment getCollectionTypeAssignment_1_0() { return cCollectionTypeAssignment_1_0; }

		//CollectionType
		public RuleCall getCollectionTypeCollectionTypeEnumRuleCall_1_0_0() { return cCollectionTypeCollectionTypeEnumRuleCall_1_0_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1_1() { return cLessThanSignKeyword_1_1; }

		//typeDeclaration=TypeDeclaration
		public Assignment getTypeDeclarationAssignment_1_2() { return cTypeDeclarationAssignment_1_2; }

		//TypeDeclaration
		public RuleCall getTypeDeclarationTypeDeclarationParserRuleCall_1_2_0() { return cTypeDeclarationTypeDeclarationParserRuleCall_1_2_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_3() { return cGreaterThanSignKeyword_1_3; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//elements=ExpressionList?
		public Assignment getElementsAssignment_3() { return cElementsAssignment_3; }

		//ExpressionList
		public RuleCall getElementsExpressionListParserRuleCall_3_0() { return cElementsExpressionListParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class TypeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeDeclaration");
		private final Assignment cTypeAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cTypeTypeCrossReference_0 = (CrossReference)cTypeAssignment.eContents().get(0);
		private final RuleCall cTypeTypeQualifiedNameParserRuleCall_0_1 = (RuleCall)cTypeTypeCrossReference_0.eContents().get(1);
		
		////TODO define collection types as well
		//TypeDeclaration: / *isAny ?= 'any' | * / type=[uml::Type|QualifiedName];
		@Override public ParserRule getRule() { return rule; }

		/// *isAny ?= 'any' | * / type=[uml::Type|QualifiedName]
		public Assignment getTypeAssignment() { return cTypeAssignment; }

		//[uml::Type|QualifiedName]
		public CrossReference getTypeTypeCrossReference_0() { return cTypeTypeCrossReference_0; }

		//QualifiedName
		public RuleCall getTypeTypeQualifiedNameParserRuleCall_0_1() { return cTypeTypeQualifiedNameParserRuleCall_0_1; }
	}

	public class IndexElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Index");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		////SequenceRange :
		////  rangeLower = Expression '..' rangeUpper = Expression
		////;
		/// * SEQUENCE ACCESS EXPRESSIONS * / Index returns Expression:
		//	"[" Expression "]";
		@Override public ParserRule getRule() { return rule; }

		//"[" Expression "]"
		public Group getGroup() { return cGroup; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}

	public class PrefixExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrefixExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPrefixExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cOperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperatorAffixOperatorEnumRuleCall_1_0 = (RuleCall)cOperatorAssignment_1.eContents().get(0);
		private final Assignment cOperandAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperandLeftHandSideParserRuleCall_2_0 = (RuleCall)cOperandAssignment_2.eContents().get(0);
		
		/// * SEQUENCE OPERATION, REDUCTION AND EXPANSION EXPRESSIONS * / // NOTE: This only covers the case when the primary is a class extent shorthand.
		////SequenceOperationOrReductionOrExpansionExpression returns Expression :
		////  {ExtentOrExpression} name = / *PotentiallyAmbiguous* /QualifiedName '->' 
		////    ( {SequenceOperationExpression.primary = current} operation = [uml::Operation|QualifiedName] tuple = Tuple 
		////    // CHANGE: Made SequenceExpansionExpression concrete.
		////    | {SequenceExpansionExpression.primary = current} operation = ID variable = Name '(' argument = Expression ')'
		////    )
		////;
		/// * INCREMENT OR DECREMENT EXPRESSIONS * / PrefixExpression returns Expression: // CHANGE: Added operator to IncrementOrDecrementExpression in the metamodel.
		//	{PrefixExpression} operator=AffixOperator operand=LeftHandSide;
		@Override public ParserRule getRule() { return rule; }

		//// CHANGE: Added operator to IncrementOrDecrementExpression in the metamodel.
		//{PrefixExpression} operator=AffixOperator operand=LeftHandSide
		public Group getGroup() { return cGroup; }

		//// CHANGE: Added operator to IncrementOrDecrementExpression in the metamodel.
		//{PrefixExpression}
		public Action getPrefixExpressionAction_0() { return cPrefixExpressionAction_0; }

		//operator=AffixOperator
		public Assignment getOperatorAssignment_1() { return cOperatorAssignment_1; }

		//AffixOperator
		public RuleCall getOperatorAffixOperatorEnumRuleCall_1_0() { return cOperatorAffixOperatorEnumRuleCall_1_0; }

		//operand=LeftHandSide
		public Assignment getOperandAssignment_2() { return cOperandAssignment_2; }

		//LeftHandSide
		public RuleCall getOperandLeftHandSideParserRuleCall_2_0() { return cOperandLeftHandSideParserRuleCall_2_0; }
	}

	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPostfixOrCastExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNonPostfixNonCastUnaryExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cPrefixExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/// * UNARY EXPRESSIONS * / UnaryExpression returns Expression:
		//	PostfixOrCastExpression | NonPostfixNonCastUnaryExpression | PrefixExpression;
		@Override public ParserRule getRule() { return rule; }

		//PostfixOrCastExpression | NonPostfixNonCastUnaryExpression | PrefixExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//PostfixOrCastExpression
		public RuleCall getPostfixOrCastExpressionParserRuleCall_0() { return cPostfixOrCastExpressionParserRuleCall_0; }

		//NonPostfixNonCastUnaryExpression
		public RuleCall getNonPostfixNonCastUnaryExpressionParserRuleCall_1() { return cNonPostfixNonCastUnaryExpressionParserRuleCall_1; }

		//PrefixExpression
		public RuleCall getPrefixExpressionParserRuleCall_2() { return cPrefixExpressionParserRuleCall_2; }
	}

	public class PostfixOrCastExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PostfixOrCastExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPostfixExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCastExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//PostfixOrCastExpression returns Expression:
		//	PostfixExpression | CastExpression | PrimaryExpression;
		@Override public ParserRule getRule() { return rule; }

		//PostfixExpression | CastExpression | PrimaryExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//PostfixExpression
		public RuleCall getPostfixExpressionParserRuleCall_0() { return cPostfixExpressionParserRuleCall_0; }

		//CastExpression
		public RuleCall getCastExpressionParserRuleCall_1() { return cCastExpressionParserRuleCall_1; }

		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_2() { return cPrimaryExpressionParserRuleCall_2; }
	}

	public class PostfixExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PostfixExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPostfixExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cOperandAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperandLeftHandSideParserRuleCall_1_0 = (RuleCall)cOperandAssignment_1.eContents().get(0);
		private final Assignment cOperatorAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperatorAffixOperatorEnumRuleCall_2_0 = (RuleCall)cOperatorAssignment_2.eContents().get(0);
		
		//PostfixExpression returns Expression:
		//	{PostfixExpression} operand=LeftHandSide operator=AffixOperator;
		@Override public ParserRule getRule() { return rule; }

		//{PostfixExpression} operand=LeftHandSide operator=AffixOperator
		public Group getGroup() { return cGroup; }

		//{PostfixExpression}
		public Action getPostfixExpressionAction_0() { return cPostfixExpressionAction_0; }

		//operand=LeftHandSide
		public Assignment getOperandAssignment_1() { return cOperandAssignment_1; }

		//LeftHandSide
		public RuleCall getOperandLeftHandSideParserRuleCall_1_0() { return cOperandLeftHandSideParserRuleCall_1_0; }

		//operator=AffixOperator
		public Assignment getOperatorAssignment_2() { return cOperatorAssignment_2; }

		//AffixOperator
		public RuleCall getOperatorAffixOperatorEnumRuleCall_2_0() { return cOperatorAffixOperatorEnumRuleCall_2_0; }
	}

	public class NonPostfixNonCastUnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NonPostfixNonCastUnaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumericUnaryExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBooleanUnaryExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBitStringUnaryExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIsolationExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//NonPostfixNonCastUnaryExpression returns Expression: //PrefixExpression | 
		//	NumericUnaryExpression | BooleanUnaryExpression | BitStringUnaryExpression | IsolationExpression;
		@Override public ParserRule getRule() { return rule; }

		////PrefixExpression | 
		//NumericUnaryExpression | BooleanUnaryExpression | BitStringUnaryExpression | IsolationExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		////PrefixExpression | 
		//NumericUnaryExpression
		public RuleCall getNumericUnaryExpressionParserRuleCall_0() { return cNumericUnaryExpressionParserRuleCall_0; }

		//BooleanUnaryExpression
		public RuleCall getBooleanUnaryExpressionParserRuleCall_1() { return cBooleanUnaryExpressionParserRuleCall_1; }

		//BitStringUnaryExpression
		public RuleCall getBitStringUnaryExpressionParserRuleCall_2() { return cBitStringUnaryExpressionParserRuleCall_2; }

		//IsolationExpression
		public RuleCall getIsolationExpressionParserRuleCall_3() { return cIsolationExpressionParserRuleCall_3; }
	}

	public class BooleanUnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanUnaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperatorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cOperatorExclamationMarkKeyword_0_0 = (Keyword)cOperatorAssignment_0.eContents().get(0);
		private final Assignment cOperandAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperandUnaryExpressionParserRuleCall_1_0 = (RuleCall)cOperandAssignment_1.eContents().get(0);
		
		//BooleanUnaryExpression:
		//	operator="!" operand=UnaryExpression;
		@Override public ParserRule getRule() { return rule; }

		//operator="!" operand=UnaryExpression
		public Group getGroup() { return cGroup; }

		//operator="!"
		public Assignment getOperatorAssignment_0() { return cOperatorAssignment_0; }

		//"!"
		public Keyword getOperatorExclamationMarkKeyword_0_0() { return cOperatorExclamationMarkKeyword_0_0; }

		//operand=UnaryExpression
		public Assignment getOperandAssignment_1() { return cOperandAssignment_1; }

		//UnaryExpression
		public RuleCall getOperandUnaryExpressionParserRuleCall_1_0() { return cOperandUnaryExpressionParserRuleCall_1_0; }
	}

	public class BitStringUnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BitStringUnaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperatorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cOperatorTildeKeyword_0_0 = (Keyword)cOperatorAssignment_0.eContents().get(0);
		private final Assignment cOperandAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperandUnaryExpressionParserRuleCall_1_0 = (RuleCall)cOperandAssignment_1.eContents().get(0);
		
		//BitStringUnaryExpression:
		//	operator="~" operand=UnaryExpression;
		@Override public ParserRule getRule() { return rule; }

		//operator="~" operand=UnaryExpression
		public Group getGroup() { return cGroup; }

		//operator="~"
		public Assignment getOperatorAssignment_0() { return cOperatorAssignment_0; }

		//"~"
		public Keyword getOperatorTildeKeyword_0_0() { return cOperatorTildeKeyword_0_0; }

		//operand=UnaryExpression
		public Assignment getOperandAssignment_1() { return cOperandAssignment_1; }

		//UnaryExpression
		public RuleCall getOperandUnaryExpressionParserRuleCall_1_0() { return cOperandUnaryExpressionParserRuleCall_1_0; }
	}

	public class NumericUnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumericUnaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cOperatorAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cOperatorNumericUnaryOperatorEnumRuleCall_0_0_0 = (RuleCall)cOperatorAssignment_0_0.eContents().get(0);
		private final Assignment cOperandAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Alternatives cOperandAlternatives_0_1_0 = (Alternatives)cOperandAssignment_0_1.eContents().get(0);
		private final RuleCall cOperandPostfixOrCastExpressionParserRuleCall_0_1_0_0 = (RuleCall)cOperandAlternatives_0_1_0.eContents().get(0);
		private final RuleCall cOperandNonPostfixNonCastUnaryExpressionParserRuleCall_0_1_0_1 = (RuleCall)cOperandAlternatives_0_1_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cOperatorAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cOperatorNumericUnaryOperatorEnumRuleCall_1_0_0 = (RuleCall)cOperatorAssignment_1_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperandPrefixExpressionParserRuleCall_1_2_0 = (RuleCall)cOperandAssignment_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//NumericUnaryExpression:
		//	operator=NumericUnaryOperator operand=(PostfixOrCastExpression | NonPostfixNonCastUnaryExpression) |
		//	operator=NumericUnaryOperator "(" operand=PrefixExpression ")";
		@Override public ParserRule getRule() { return rule; }

		//operator=NumericUnaryOperator operand=(PostfixOrCastExpression | NonPostfixNonCastUnaryExpression) |
		//operator=NumericUnaryOperator "(" operand=PrefixExpression ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//operator=NumericUnaryOperator operand=(PostfixOrCastExpression | NonPostfixNonCastUnaryExpression)
		public Group getGroup_0() { return cGroup_0; }

		//operator=NumericUnaryOperator
		public Assignment getOperatorAssignment_0_0() { return cOperatorAssignment_0_0; }

		//NumericUnaryOperator
		public RuleCall getOperatorNumericUnaryOperatorEnumRuleCall_0_0_0() { return cOperatorNumericUnaryOperatorEnumRuleCall_0_0_0; }

		//operand=(PostfixOrCastExpression | NonPostfixNonCastUnaryExpression)
		public Assignment getOperandAssignment_0_1() { return cOperandAssignment_0_1; }

		//PostfixOrCastExpression | NonPostfixNonCastUnaryExpression
		public Alternatives getOperandAlternatives_0_1_0() { return cOperandAlternatives_0_1_0; }

		//PostfixOrCastExpression
		public RuleCall getOperandPostfixOrCastExpressionParserRuleCall_0_1_0_0() { return cOperandPostfixOrCastExpressionParserRuleCall_0_1_0_0; }

		//NonPostfixNonCastUnaryExpression
		public RuleCall getOperandNonPostfixNonCastUnaryExpressionParserRuleCall_0_1_0_1() { return cOperandNonPostfixNonCastUnaryExpressionParserRuleCall_0_1_0_1; }

		//operator=NumericUnaryOperator "(" operand=PrefixExpression ")"
		public Group getGroup_1() { return cGroup_1; }

		//operator=NumericUnaryOperator
		public Assignment getOperatorAssignment_1_0() { return cOperatorAssignment_1_0; }

		//NumericUnaryOperator
		public RuleCall getOperatorNumericUnaryOperatorEnumRuleCall_1_0_0() { return cOperatorNumericUnaryOperatorEnumRuleCall_1_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//operand=PrefixExpression
		public Assignment getOperandAssignment_1_2() { return cOperandAssignment_1_2; }

		//PrefixExpression
		public RuleCall getOperandPrefixExpressionParserRuleCall_1_2_0() { return cOperandPrefixExpressionParserRuleCall_1_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}

	public class IsolationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IsolationExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperatorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cOperatorDollarSignKeyword_0_0 = (Keyword)cOperatorAssignment_0.eContents().get(0);
		private final Assignment cOperandAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperandUnaryExpressionParserRuleCall_1_0 = (RuleCall)cOperandAssignment_1.eContents().get(0);
		
		//IsolationExpression:
		//	operator="$" operand=UnaryExpression;
		@Override public ParserRule getRule() { return rule; }

		//operator="$" operand=UnaryExpression
		public Group getGroup() { return cGroup; }

		//operator="$"
		public Assignment getOperatorAssignment_0() { return cOperatorAssignment_0; }

		//"$"
		public Keyword getOperatorDollarSignKeyword_0_0() { return cOperatorDollarSignKeyword_0_0; }

		//operand=UnaryExpression
		public Assignment getOperandAssignment_1() { return cOperandAssignment_1; }

		//UnaryExpression
		public RuleCall getOperandUnaryExpressionParserRuleCall_1_0() { return cOperandUnaryExpressionParserRuleCall_1_0; }
	}

	public class CastExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CastExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeTypeDeclarationParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOperandAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOperandCastCompletionParserRuleCall_3_0 = (RuleCall)cOperandAssignment_3.eContents().get(0);
		
		//CastExpression:
		//	"(" type=TypeDeclaration ")" operand=CastCompletion;
		@Override public ParserRule getRule() { return rule; }

		//"(" type=TypeDeclaration ")" operand=CastCompletion
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//type=TypeDeclaration
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//TypeDeclaration
		public RuleCall getTypeTypeDeclarationParserRuleCall_1_0() { return cTypeTypeDeclarationParserRuleCall_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }

		//operand=CastCompletion
		public Assignment getOperandAssignment_3() { return cOperandAssignment_3; }

		//CastCompletion
		public RuleCall getOperandCastCompletionParserRuleCall_3_0() { return cOperandCastCompletionParserRuleCall_3_0; }
	}

	public class CastCompletionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CastCompletion");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPostfixOrCastExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBooleanUnaryExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBitStringUnaryExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIsolationExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//CastCompletion returns Expression:
		//	PostfixOrCastExpression | BooleanUnaryExpression | BitStringUnaryExpression | IsolationExpression;
		@Override public ParserRule getRule() { return rule; }

		//PostfixOrCastExpression | BooleanUnaryExpression | BitStringUnaryExpression | IsolationExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//PostfixOrCastExpression
		public RuleCall getPostfixOrCastExpressionParserRuleCall_0() { return cPostfixOrCastExpressionParserRuleCall_0; }

		//BooleanUnaryExpression
		public RuleCall getBooleanUnaryExpressionParserRuleCall_1() { return cBooleanUnaryExpressionParserRuleCall_1; }

		//BitStringUnaryExpression
		public RuleCall getBitStringUnaryExpressionParserRuleCall_2() { return cBitStringUnaryExpressionParserRuleCall_2; }

		//IsolationExpression
		public RuleCall getIsolationExpressionParserRuleCall_3() { return cIsolationExpressionParserRuleCall_3; }
	}

	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArithmeticExpressionOperand1Action_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorMultiplicativeOperatorParserRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cOperand2Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperand2UnaryExpressionParserRuleCall_1_2_0 = (RuleCall)cOperand2Assignment_1_2.eContents().get(0);
		
		/// * ARITHMETIC EXPRESSIONS * / MultiplicativeExpression returns Expression:
		//	UnaryExpression ({ArithmeticExpression.operand1=current} operator=MultiplicativeOperator operand2=UnaryExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//UnaryExpression ({ArithmeticExpression.operand1=current} operator=MultiplicativeOperator operand2=UnaryExpression)*
		public Group getGroup() { return cGroup; }

		//UnaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_0() { return cUnaryExpressionParserRuleCall_0; }

		//({ArithmeticExpression.operand1=current} operator=MultiplicativeOperator operand2=UnaryExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{ArithmeticExpression.operand1=current}
		public Action getArithmeticExpressionOperand1Action_1_0() { return cArithmeticExpressionOperand1Action_1_0; }

		//operator=MultiplicativeOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//MultiplicativeOperator
		public RuleCall getOperatorMultiplicativeOperatorParserRuleCall_1_1_0() { return cOperatorMultiplicativeOperatorParserRuleCall_1_1_0; }

		//operand2=UnaryExpression
		public Assignment getOperand2Assignment_1_2() { return cOperand2Assignment_1_2; }

		//UnaryExpression
		public RuleCall getOperand2UnaryExpressionParserRuleCall_1_2_0() { return cOperand2UnaryExpressionParserRuleCall_1_2_0; }
	}

	public class MultiplicativeOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicativeOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAsteriskKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSolidusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cPercentSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//MultiplicativeOperator:
		//	"*" | "/" | "%";
		@Override public ParserRule getRule() { return rule; }

		//"*" | "/" | "%"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"*"
		public Keyword getAsteriskKeyword_0() { return cAsteriskKeyword_0; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//"%"
		public Keyword getPercentSignKeyword_2() { return cPercentSignKeyword_2; }
	}

	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArithmeticExpressionOperand1Action_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorAdditiveOperatorParserRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cOperand2Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperand2MultiplicativeExpressionParserRuleCall_1_2_0 = (RuleCall)cOperand2Assignment_1_2.eContents().get(0);
		
		//AdditiveExpression returns Expression:
		//	MultiplicativeExpression ({ArithmeticExpression.operand1=current} operator=AdditiveOperator
		//	operand2=MultiplicativeExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//MultiplicativeExpression ({ArithmeticExpression.operand1=current} operator=AdditiveOperator
		//operand2=MultiplicativeExpression)*
		public Group getGroup() { return cGroup; }

		//MultiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }

		//({ArithmeticExpression.operand1=current} operator=AdditiveOperator operand2=MultiplicativeExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{ArithmeticExpression.operand1=current}
		public Action getArithmeticExpressionOperand1Action_1_0() { return cArithmeticExpressionOperand1Action_1_0; }

		//operator=AdditiveOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//AdditiveOperator
		public RuleCall getOperatorAdditiveOperatorParserRuleCall_1_1_0() { return cOperatorAdditiveOperatorParserRuleCall_1_1_0; }

		//operand2=MultiplicativeExpression
		public Assignment getOperand2Assignment_1_2() { return cOperand2Assignment_1_2; }

		//MultiplicativeExpression
		public RuleCall getOperand2MultiplicativeExpressionParserRuleCall_1_2_0() { return cOperand2MultiplicativeExpressionParserRuleCall_1_2_0; }
	}

	public class AdditiveOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditiveOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cPlusSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//AdditiveOperator:
		//	"+" | "-";
		@Override public ParserRule getRule() { return rule; }

		//"+" | "-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"+"
		public Keyword getPlusSignKeyword_0() { return cPlusSignKeyword_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }
	}

	public class ShiftExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ShiftExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cShiftExpressionOperand1Action_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorShiftOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cOperand2Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperand2AdditiveExpressionParserRuleCall_1_2_0 = (RuleCall)cOperand2Assignment_1_2.eContents().get(0);
		
		/// * SHIFT EXPRESSIONS * / ShiftExpression returns Expression:
		//	AdditiveExpression ({ShiftExpression.operand1=current} operator=ShiftOperator operand2=AdditiveExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//AdditiveExpression ({ShiftExpression.operand1=current} operator=ShiftOperator operand2=AdditiveExpression)*
		public Group getGroup() { return cGroup; }

		//AdditiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }

		//({ShiftExpression.operand1=current} operator=ShiftOperator operand2=AdditiveExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{ShiftExpression.operand1=current}
		public Action getShiftExpressionOperand1Action_1_0() { return cShiftExpressionOperand1Action_1_0; }

		//operator=ShiftOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//ShiftOperator
		public RuleCall getOperatorShiftOperatorEnumRuleCall_1_1_0() { return cOperatorShiftOperatorEnumRuleCall_1_1_0; }

		//operand2=AdditiveExpression
		public Assignment getOperand2Assignment_1_2() { return cOperand2Assignment_1_2; }

		//AdditiveExpression
		public RuleCall getOperand2AdditiveExpressionParserRuleCall_1_2_0() { return cOperand2AdditiveExpressionParserRuleCall_1_2_0; }
	}

	public class RelationalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cShiftExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRelationalExpressionOperand1Action_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorRelationalOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cOperand2Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperand2ShiftExpressionParserRuleCall_1_2_0 = (RuleCall)cOperand2Assignment_1_2.eContents().get(0);
		
		/// * RELATIONAL EXPRESSIONS * / RelationalExpression returns Expression:
		//	ShiftExpression ({RelationalExpression.operand1=current} operator=RelationalOperator operand2=ShiftExpression)?;
		@Override public ParserRule getRule() { return rule; }

		//ShiftExpression ({RelationalExpression.operand1=current} operator=RelationalOperator operand2=ShiftExpression)?
		public Group getGroup() { return cGroup; }

		//ShiftExpression
		public RuleCall getShiftExpressionParserRuleCall_0() { return cShiftExpressionParserRuleCall_0; }

		//({RelationalExpression.operand1=current} operator=RelationalOperator operand2=ShiftExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{RelationalExpression.operand1=current}
		public Action getRelationalExpressionOperand1Action_1_0() { return cRelationalExpressionOperand1Action_1_0; }

		//operator=RelationalOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//RelationalOperator
		public RuleCall getOperatorRelationalOperatorEnumRuleCall_1_1_0() { return cOperatorRelationalOperatorEnumRuleCall_1_1_0; }

		//operand2=ShiftExpression
		public Assignment getOperand2Assignment_1_2() { return cOperand2Assignment_1_2; }

		//ShiftExpression
		public RuleCall getOperand2ShiftExpressionParserRuleCall_1_2_0() { return cOperand2ShiftExpressionParserRuleCall_1_2_0; }
	}

	public class ClassificationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClassificationExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationalExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cClassificationExpressionOperandAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorClassificationOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final CrossReference cTypeClassCrossReference_1_2_0 = (CrossReference)cTypeAssignment_1_2.eContents().get(0);
		private final RuleCall cTypeClassQualifiedNameParserRuleCall_1_2_0_1 = (RuleCall)cTypeClassCrossReference_1_2_0.eContents().get(1);
		
		/// * CLASSIFICATION EXPRESSIONS * / ClassificationExpression returns Expression:
		//	RelationalExpression ({ClassificationExpression.operand=current} operator=ClassificationOperator
		//	type=[uml::Class|QualifiedName])?;
		@Override public ParserRule getRule() { return rule; }

		//RelationalExpression ({ClassificationExpression.operand=current} operator=ClassificationOperator
		//type=[uml::Class|QualifiedName])?
		public Group getGroup() { return cGroup; }

		//RelationalExpression
		public RuleCall getRelationalExpressionParserRuleCall_0() { return cRelationalExpressionParserRuleCall_0; }

		//({ClassificationExpression.operand=current} operator=ClassificationOperator type=[uml::Class|QualifiedName])?
		public Group getGroup_1() { return cGroup_1; }

		//{ClassificationExpression.operand=current}
		public Action getClassificationExpressionOperandAction_1_0() { return cClassificationExpressionOperandAction_1_0; }

		//operator=ClassificationOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//ClassificationOperator
		public RuleCall getOperatorClassificationOperatorEnumRuleCall_1_1_0() { return cOperatorClassificationOperatorEnumRuleCall_1_1_0; }

		//type=[uml::Class|QualifiedName]
		public Assignment getTypeAssignment_1_2() { return cTypeAssignment_1_2; }

		//[uml::Class|QualifiedName]
		public CrossReference getTypeClassCrossReference_1_2_0() { return cTypeClassCrossReference_1_2_0; }

		//QualifiedName
		public RuleCall getTypeClassQualifiedNameParserRuleCall_1_2_0_1() { return cTypeClassQualifiedNameParserRuleCall_1_2_0_1; }
	}

	public class EqualityExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EqualityExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cClassificationExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEqualityExpressionOperand1Action_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorEqualityOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cOperand2Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperand2ClassificationExpressionParserRuleCall_1_2_0 = (RuleCall)cOperand2Assignment_1_2.eContents().get(0);
		
		/// * EQUALITY EXPRESSIONS * / EqualityExpression returns Expression:
		//	ClassificationExpression ({EqualityExpression.operand1=current} operator=EqualityOperator
		//	operand2=ClassificationExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//ClassificationExpression ({EqualityExpression.operand1=current} operator=EqualityOperator
		//operand2=ClassificationExpression)*
		public Group getGroup() { return cGroup; }

		//ClassificationExpression
		public RuleCall getClassificationExpressionParserRuleCall_0() { return cClassificationExpressionParserRuleCall_0; }

		//({EqualityExpression.operand1=current} operator=EqualityOperator operand2=ClassificationExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{EqualityExpression.operand1=current}
		public Action getEqualityExpressionOperand1Action_1_0() { return cEqualityExpressionOperand1Action_1_0; }

		//operator=EqualityOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//EqualityOperator
		public RuleCall getOperatorEqualityOperatorEnumRuleCall_1_1_0() { return cOperatorEqualityOperatorEnumRuleCall_1_1_0; }

		//operand2=ClassificationExpression
		public Assignment getOperand2Assignment_1_2() { return cOperand2Assignment_1_2; }

		//ClassificationExpression
		public RuleCall getOperand2ClassificationExpressionParserRuleCall_1_2_0() { return cOperand2ClassificationExpressionParserRuleCall_1_2_0; }
	}

	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualityExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalExpressionOperand1Action_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperatorAmpersandKeyword_1_1_0 = (Keyword)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cOperand2Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperand2EqualityExpressionParserRuleCall_1_2_0 = (RuleCall)cOperand2Assignment_1_2.eContents().get(0);
		
		/// * LOGICAL EXPRESSIONS * / AndExpression returns Expression:
		//	EqualityExpression ({LogicalExpression.operand1=current} operator="&" operand2=EqualityExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//EqualityExpression ({LogicalExpression.operand1=current} operator="&" operand2=EqualityExpression)*
		public Group getGroup() { return cGroup; }

		//EqualityExpression
		public RuleCall getEqualityExpressionParserRuleCall_0() { return cEqualityExpressionParserRuleCall_0; }

		//({LogicalExpression.operand1=current} operator="&" operand2=EqualityExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{LogicalExpression.operand1=current}
		public Action getLogicalExpressionOperand1Action_1_0() { return cLogicalExpressionOperand1Action_1_0; }

		//operator="&"
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//"&"
		public Keyword getOperatorAmpersandKeyword_1_1_0() { return cOperatorAmpersandKeyword_1_1_0; }

		//operand2=EqualityExpression
		public Assignment getOperand2Assignment_1_2() { return cOperand2Assignment_1_2; }

		//EqualityExpression
		public RuleCall getOperand2EqualityExpressionParserRuleCall_1_2_0() { return cOperand2EqualityExpressionParserRuleCall_1_2_0; }
	}

	public class ExclusiveOrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExclusiveOrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalExpressionOperand1Action_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperatorCircumflexAccentKeyword_1_1_0 = (Keyword)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cOperand2Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperand2AndExpressionParserRuleCall_1_2_0 = (RuleCall)cOperand2Assignment_1_2.eContents().get(0);
		
		//ExclusiveOrExpression returns Expression:
		//	AndExpression ({LogicalExpression.operand1=current} operator="^" operand2=AndExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//AndExpression ({LogicalExpression.operand1=current} operator="^" operand2=AndExpression)*
		public Group getGroup() { return cGroup; }

		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }

		//({LogicalExpression.operand1=current} operator="^" operand2=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{LogicalExpression.operand1=current}
		public Action getLogicalExpressionOperand1Action_1_0() { return cLogicalExpressionOperand1Action_1_0; }

		//operator="^"
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//"^"
		public Keyword getOperatorCircumflexAccentKeyword_1_1_0() { return cOperatorCircumflexAccentKeyword_1_1_0; }

		//operand2=AndExpression
		public Assignment getOperand2Assignment_1_2() { return cOperand2Assignment_1_2; }

		//AndExpression
		public RuleCall getOperand2AndExpressionParserRuleCall_1_2_0() { return cOperand2AndExpressionParserRuleCall_1_2_0; }
	}

	public class InclusiveOrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InclusiveOrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExclusiveOrExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cLogicalExpressionOperand1Action_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperatorVerticalLineKeyword_1_1_0 = (Keyword)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cOperand2Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperand2ExclusiveOrExpressionParserRuleCall_1_2_0 = (RuleCall)cOperand2Assignment_1_2.eContents().get(0);
		
		//InclusiveOrExpression returns Expression:
		//	ExclusiveOrExpression ({LogicalExpression.operand1=current} operator="|" operand2=ExclusiveOrExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//ExclusiveOrExpression ({LogicalExpression.operand1=current} operator="|" operand2=ExclusiveOrExpression)*
		public Group getGroup() { return cGroup; }

		//ExclusiveOrExpression
		public RuleCall getExclusiveOrExpressionParserRuleCall_0() { return cExclusiveOrExpressionParserRuleCall_0; }

		//({LogicalExpression.operand1=current} operator="|" operand2=ExclusiveOrExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{LogicalExpression.operand1=current}
		public Action getLogicalExpressionOperand1Action_1_0() { return cLogicalExpressionOperand1Action_1_0; }

		//operator="|"
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//"|"
		public Keyword getOperatorVerticalLineKeyword_1_1_0() { return cOperatorVerticalLineKeyword_1_1_0; }

		//operand2=ExclusiveOrExpression
		public Assignment getOperand2Assignment_1_2() { return cOperand2Assignment_1_2; }

		//ExclusiveOrExpression
		public RuleCall getOperand2ExclusiveOrExpressionParserRuleCall_1_2_0() { return cOperand2ExclusiveOrExpressionParserRuleCall_1_2_0; }
	}

	public class ConditionalAndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConditionalAndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cInclusiveOrExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cConditionalLogicalExpressionOperand1Action_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperatorAmpersandAmpersandKeyword_1_1_0 = (Keyword)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cOperand2Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperand2InclusiveOrExpressionParserRuleCall_1_2_0 = (RuleCall)cOperand2Assignment_1_2.eContents().get(0);
		
		/// * CONDITIONAL LOGICAL EXPRESSIONS * / ConditionalAndExpression returns Expression:
		//	InclusiveOrExpression ({ConditionalLogicalExpression.operand1=current} operator="&&"
		//	operand2=InclusiveOrExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//InclusiveOrExpression ({ConditionalLogicalExpression.operand1=current} operator="&&" operand2=InclusiveOrExpression)*
		public Group getGroup() { return cGroup; }

		//InclusiveOrExpression
		public RuleCall getInclusiveOrExpressionParserRuleCall_0() { return cInclusiveOrExpressionParserRuleCall_0; }

		//({ConditionalLogicalExpression.operand1=current} operator="&&" operand2=InclusiveOrExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{ConditionalLogicalExpression.operand1=current}
		public Action getConditionalLogicalExpressionOperand1Action_1_0() { return cConditionalLogicalExpressionOperand1Action_1_0; }

		//operator="&&"
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//"&&"
		public Keyword getOperatorAmpersandAmpersandKeyword_1_1_0() { return cOperatorAmpersandAmpersandKeyword_1_1_0; }

		//operand2=InclusiveOrExpression
		public Assignment getOperand2Assignment_1_2() { return cOperand2Assignment_1_2; }

		//InclusiveOrExpression
		public RuleCall getOperand2InclusiveOrExpressionParserRuleCall_1_2_0() { return cOperand2InclusiveOrExpressionParserRuleCall_1_2_0; }
	}

	public class ConditionalOrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConditionalOrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cConditionalAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cConditionalLogicalExpressionOperand1Action_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperatorVerticalLineVerticalLineKeyword_1_1_0 = (Keyword)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cOperand2Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperand2ConditionalAndExpressionParserRuleCall_1_2_0 = (RuleCall)cOperand2Assignment_1_2.eContents().get(0);
		
		//ConditionalOrExpression returns Expression:
		//	ConditionalAndExpression ({ConditionalLogicalExpression.operand1=current} operator="||"
		//	operand2=ConditionalAndExpression)*;
		@Override public ParserRule getRule() { return rule; }

		//ConditionalAndExpression ({ConditionalLogicalExpression.operand1=current} operator="||"
		//operand2=ConditionalAndExpression)*
		public Group getGroup() { return cGroup; }

		//ConditionalAndExpression
		public RuleCall getConditionalAndExpressionParserRuleCall_0() { return cConditionalAndExpressionParserRuleCall_0; }

		//({ConditionalLogicalExpression.operand1=current} operator="||" operand2=ConditionalAndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{ConditionalLogicalExpression.operand1=current}
		public Action getConditionalLogicalExpressionOperand1Action_1_0() { return cConditionalLogicalExpressionOperand1Action_1_0; }

		//operator="||"
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//"||"
		public Keyword getOperatorVerticalLineVerticalLineKeyword_1_1_0() { return cOperatorVerticalLineVerticalLineKeyword_1_1_0; }

		//operand2=ConditionalAndExpression
		public Assignment getOperand2Assignment_1_2() { return cOperand2Assignment_1_2; }

		//ConditionalAndExpression
		public RuleCall getOperand2ConditionalAndExpressionParserRuleCall_1_2_0() { return cOperand2ConditionalAndExpressionParserRuleCall_1_2_0; }
	}

	public class ConditionalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConditionalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cConditionalOrExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cConditionalTestExpressionOperand1Action_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cQuestionMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cOperand2Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOperand2ExpressionParserRuleCall_1_2_0 = (RuleCall)cOperand2Assignment_1_2.eContents().get(0);
		private final Keyword cColonKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cOperand3Assignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cOperand3ConditionalExpressionParserRuleCall_1_4_0 = (RuleCall)cOperand3Assignment_1_4.eContents().get(0);
		
		/// * CONDITIONAL-TEST EXPRESSIONS * / ConditionalExpression returns Expression:
		//	ConditionalOrExpression ({ConditionalTestExpression.operand1=current} "?" operand2=Expression ":"
		//	operand3=ConditionalExpression)?;
		@Override public ParserRule getRule() { return rule; }

		//ConditionalOrExpression ({ConditionalTestExpression.operand1=current} "?" operand2=Expression ":"
		//operand3=ConditionalExpression)?
		public Group getGroup() { return cGroup; }

		//ConditionalOrExpression
		public RuleCall getConditionalOrExpressionParserRuleCall_0() { return cConditionalOrExpressionParserRuleCall_0; }

		//({ConditionalTestExpression.operand1=current} "?" operand2=Expression ":" operand3=ConditionalExpression)?
		public Group getGroup_1() { return cGroup_1; }

		//{ConditionalTestExpression.operand1=current}
		public Action getConditionalTestExpressionOperand1Action_1_0() { return cConditionalTestExpressionOperand1Action_1_0; }

		//"?"
		public Keyword getQuestionMarkKeyword_1_1() { return cQuestionMarkKeyword_1_1; }

		//operand2=Expression
		public Assignment getOperand2Assignment_1_2() { return cOperand2Assignment_1_2; }

		//Expression
		public RuleCall getOperand2ExpressionParserRuleCall_1_2_0() { return cOperand2ExpressionParserRuleCall_1_2_0; }

		//":"
		public Keyword getColonKeyword_1_3() { return cColonKeyword_1_3; }

		//operand3=ConditionalExpression
		public Assignment getOperand3Assignment_1_4() { return cOperand3Assignment_1_4; }

		//ConditionalExpression
		public RuleCall getOperand3ConditionalExpressionParserRuleCall_1_4_0() { return cOperand3ConditionalExpressionParserRuleCall_1_4_0; }
	}

	public class AssignmentExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssignmentExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftHandSideAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftHandSideLeftHandSideParserRuleCall_0_0 = (RuleCall)cLeftHandSideAssignment_0.eContents().get(0);
		private final Assignment cOperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperatorAssignmentOperatorEnumRuleCall_1_0 = (RuleCall)cOperatorAssignment_1.eContents().get(0);
		private final Assignment cRightHandSideAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightHandSideExpressionParserRuleCall_2_0 = (RuleCall)cRightHandSideAssignment_2.eContents().get(0);
		
		/// * ASSIGNMENT EXPRESSIONS * / AssignmentExpression:
		//	leftHandSide=LeftHandSide operator=AssignmentOperator rightHandSide=Expression;
		@Override public ParserRule getRule() { return rule; }

		//leftHandSide=LeftHandSide operator=AssignmentOperator rightHandSide=Expression
		public Group getGroup() { return cGroup; }

		//leftHandSide=LeftHandSide
		public Assignment getLeftHandSideAssignment_0() { return cLeftHandSideAssignment_0; }

		//LeftHandSide
		public RuleCall getLeftHandSideLeftHandSideParserRuleCall_0_0() { return cLeftHandSideLeftHandSideParserRuleCall_0_0; }

		//operator=AssignmentOperator
		public Assignment getOperatorAssignment_1() { return cOperatorAssignment_1; }

		//AssignmentOperator
		public RuleCall getOperatorAssignmentOperatorEnumRuleCall_1_0() { return cOperatorAssignmentOperatorEnumRuleCall_1_0; }

		//rightHandSide=Expression
		public Assignment getRightHandSideAssignment_2() { return cRightHandSideAssignment_2; }

		//Expression
		public RuleCall getRightHandSideExpressionParserRuleCall_2_0() { return cRightHandSideExpressionParserRuleCall_2_0; }
	}

	public class LeftHandSideElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LeftHandSide");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNameLeftHandSideParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFeatureLeftHandSideParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////  "(" LeftHandSide ")"
		//LeftHandSide:
		//	NameLeftHandSide | // ( index = Index )? | //TODO Indexing
		//	FeatureLeftHandSide;
		@Override public ParserRule getRule() { return rule; }

		//NameLeftHandSide | // ( index = Index )? | //TODO Indexing
		//FeatureLeftHandSide
		public Alternatives getAlternatives() { return cAlternatives; }

		//NameLeftHandSide
		public RuleCall getNameLeftHandSideParserRuleCall_0() { return cNameLeftHandSideParserRuleCall_0; }

		//// ( index = Index )? | //TODO Indexing
		//FeatureLeftHandSide
		public RuleCall getFeatureLeftHandSideParserRuleCall_1() { return cFeatureLeftHandSideParserRuleCall_1; }
	}

	public class NameLeftHandSideElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NameLeftHandSide");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionNameExpressionParserRuleCall_0_0 = (RuleCall)cExpressionAssignment_0.eContents().get(0);
		private final Assignment cIndexAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIndexIndexParserRuleCall_1_0 = (RuleCall)cIndexAssignment_1.eContents().get(0);
		
		//NameLeftHandSide: // CHANGE: Moved the index property from LeftHandSide down to just NameLeftHandSide.
		//	expression=NameExpression index=Index?;
		@Override public ParserRule getRule() { return rule; }

		//// CHANGE: Moved the index property from LeftHandSide down to just NameLeftHandSide.
		//expression=NameExpression index=Index?
		public Group getGroup() { return cGroup; }

		//// CHANGE: Moved the index property from LeftHandSide down to just NameLeftHandSide.
		//expression=NameExpression
		public Assignment getExpressionAssignment_0() { return cExpressionAssignment_0; }

		//NameExpression
		public RuleCall getExpressionNameExpressionParserRuleCall_0_0() { return cExpressionNameExpressionParserRuleCall_0_0; }

		//index=Index?
		public Assignment getIndexAssignment_1() { return cIndexAssignment_1; }

		//Index
		public RuleCall getIndexIndexParserRuleCall_1_0() { return cIndexIndexParserRuleCall_1_0; }
	}

	public class FeatureLeftHandSideElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FeatureLeftHandSide");
		private final Assignment cExpressionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cExpressionPropertyAccessExpressionParserRuleCall_0 = (RuleCall)cExpressionAssignment.eContents().get(0);
		
		//FeatureLeftHandSide: // CHANGE: Replaced the feature property of a FeatureLeftHandSide with expression.
		//	expression=PropertyAccessExpression;
		@Override public ParserRule getRule() { return rule; }

		//// CHANGE: Replaced the feature property of a FeatureLeftHandSide with expression.
		//expression=PropertyAccessExpression
		public Assignment getExpressionAssignment() { return cExpressionAssignment; }

		//PropertyAccessExpression
		public RuleCall getExpressionPropertyAccessExpressionParserRuleCall_0() { return cExpressionPropertyAccessExpressionParserRuleCall_0; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cSimpleStatementParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final RuleCall cBlockStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIfStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSwitchStatementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cWhileStatementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cForStatementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cForEachStatementParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cDoStatementParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cBreakStatementParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cReturnStatementParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cClassifyStatementParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cSendSignalStatementParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		
		/// **************
		// * STATEMENTS *
		// ************** / Statement:
		//	SimpleStatement ";" | BlockStatement | IfStatement | SwitchStatement | WhileStatement | ForStatement |
		//	ForEachStatement | DoStatement | BreakStatement | ReturnStatement | ClassifyStatement | SendSignalStatement;
		@Override public ParserRule getRule() { return rule; }

		//SimpleStatement ";" | BlockStatement | IfStatement | SwitchStatement | WhileStatement | ForStatement | ForEachStatement
		//| DoStatement | BreakStatement | ReturnStatement | ClassifyStatement | SendSignalStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//SimpleStatement ";"
		public Group getGroup_0() { return cGroup_0; }

		//SimpleStatement
		public RuleCall getSimpleStatementParserRuleCall_0_0() { return cSimpleStatementParserRuleCall_0_0; }

		//";"
		public Keyword getSemicolonKeyword_0_1() { return cSemicolonKeyword_0_1; }

		//BlockStatement
		public RuleCall getBlockStatementParserRuleCall_1() { return cBlockStatementParserRuleCall_1; }

		//IfStatement
		public RuleCall getIfStatementParserRuleCall_2() { return cIfStatementParserRuleCall_2; }

		//SwitchStatement
		public RuleCall getSwitchStatementParserRuleCall_3() { return cSwitchStatementParserRuleCall_3; }

		//WhileStatement
		public RuleCall getWhileStatementParserRuleCall_4() { return cWhileStatementParserRuleCall_4; }

		//ForStatement
		public RuleCall getForStatementParserRuleCall_5() { return cForStatementParserRuleCall_5; }

		//ForEachStatement
		public RuleCall getForEachStatementParserRuleCall_6() { return cForEachStatementParserRuleCall_6; }

		//DoStatement
		public RuleCall getDoStatementParserRuleCall_7() { return cDoStatementParserRuleCall_7; }

		//BreakStatement
		public RuleCall getBreakStatementParserRuleCall_8() { return cBreakStatementParserRuleCall_8; }

		//ReturnStatement
		public RuleCall getReturnStatementParserRuleCall_9() { return cReturnStatementParserRuleCall_9; }

		//ClassifyStatement
		public RuleCall getClassifyStatementParserRuleCall_10() { return cClassifyStatementParserRuleCall_10; }

		//SendSignalStatement
		public RuleCall getSendSignalStatementParserRuleCall_11() { return cSendSignalStatementParserRuleCall_11; }
	}

	public class SimpleStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SimpleStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLocalNameDeclarationStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEmptyStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//SimpleStatement:
		//	LocalNameDeclarationStatement | ExpressionStatement | EmptyStatement;
		@Override public ParserRule getRule() { return rule; }

		//LocalNameDeclarationStatement | ExpressionStatement | EmptyStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//LocalNameDeclarationStatement
		public RuleCall getLocalNameDeclarationStatementParserRuleCall_0() { return cLocalNameDeclarationStatementParserRuleCall_0; }

		//ExpressionStatement
		public RuleCall getExpressionStatementParserRuleCall_1() { return cExpressionStatementParserRuleCall_1; }

		//EmptyStatement
		public RuleCall getEmptyStatementParserRuleCall_2() { return cEmptyStatementParserRuleCall_2; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStatementAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementStatementParserRuleCall_2_0 = (RuleCall)cStatementAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// * BLOCK * / Block:
		//	{Block} "{" statement+=Statement* "}";
		@Override public ParserRule getRule() { return rule; }

		//{Block} "{" statement+=Statement* "}"
		public Group getGroup() { return cGroup; }

		//{Block}
		public Action getBlockAction_0() { return cBlockAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//statement+=Statement*
		public Assignment getStatementAssignment_2() { return cStatementAssignment_2; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_2_0() { return cStatementStatementParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class BlockStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BlockStatement");
		private final RuleCall cBlockParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/// * BLOCK STATEMENTS * / BlockStatement:
		//	Block;
		@Override public ParserRule getRule() { return rule; }

		//Block
		public RuleCall getBlockParserRuleCall() { return cBlockParserRuleCall; }
	}

	public class EmptyStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EmptyStatement");
		private final Action cEmptyStatementAction = (Action)rule.eContents().get(1);
		
		/// * EMPTY STATEMENTS * / EmptyStatement:
		//	{EmptyStatement};
		@Override public ParserRule getRule() { return rule; }

		//{EmptyStatement}
		public Action getEmptyStatementAction() { return cEmptyStatementAction; }
	}

	public class MultiplicityIndicatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicityIndicator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//MultiplicityIndicator:
		//	"[" "]";
		@Override public ParserRule getRule() { return rule; }

		//"[" "]"
		public Group getGroup() { return cGroup; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1() { return cRightSquareBracketKeyword_1; }
	}

	public class VariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVariableAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeTypeDeclarationParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cHasMultiplicityAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cHasMultiplicityMultiplicityIndicatorParserRuleCall_2_0 = (RuleCall)cHasMultiplicityAssignment_2.eContents().get(0);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameNameParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		
		//VariableDeclaration returns uml::NamedElement:
		//	{Variable} type=TypeDeclaration hasMultiplicity?=MultiplicityIndicator? name=Name;
		@Override public ParserRule getRule() { return rule; }

		//{Variable} type=TypeDeclaration hasMultiplicity?=MultiplicityIndicator? name=Name
		public Group getGroup() { return cGroup; }

		//{Variable}
		public Action getVariableAction_0() { return cVariableAction_0; }

		//type=TypeDeclaration
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//TypeDeclaration
		public RuleCall getTypeTypeDeclarationParserRuleCall_1_0() { return cTypeTypeDeclarationParserRuleCall_1_0; }

		//hasMultiplicity?=MultiplicityIndicator?
		public Assignment getHasMultiplicityAssignment_2() { return cHasMultiplicityAssignment_2; }

		//MultiplicityIndicator
		public RuleCall getHasMultiplicityMultiplicityIndicatorParserRuleCall_2_0() { return cHasMultiplicityMultiplicityIndicatorParserRuleCall_2_0; }

		//name=Name
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//Name
		public RuleCall getNameNameParserRuleCall_3_0() { return cNameNameParserRuleCall_3_0; }
	}

	public class LocalNameDeclarationStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LocalNameDeclarationStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariableVariableDeclarationParserRuleCall_0_0 = (RuleCall)cVariableAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionInitializationExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		/// * LOCAL NAME DECLARATION STATEMENTS * / LocalNameDeclarationStatement:
		//	variable=VariableDeclaration "=" expression=InitializationExpression;
		@Override public ParserRule getRule() { return rule; }

		//variable=VariableDeclaration "=" expression=InitializationExpression
		public Group getGroup() { return cGroup; }

		//variable=VariableDeclaration
		public Assignment getVariableAssignment_0() { return cVariableAssignment_0; }

		//VariableDeclaration
		public RuleCall getVariableVariableDeclarationParserRuleCall_0_0() { return cVariableVariableDeclarationParserRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//expression=InitializationExpression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//InitializationExpression
		public RuleCall getExpressionInitializationExpressionParserRuleCall_2_0() { return cExpressionInitializationExpressionParserRuleCall_2_0; }
	}

	public class InitializationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InitializationExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cInstanceInitializationExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//InitializationExpression returns Expression:
		//	Expression | InstanceInitializationExpression;
		@Override public ParserRule getRule() { return rule; }

		//Expression | InstanceInitializationExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0() { return cExpressionParserRuleCall_0; }

		//InstanceInitializationExpression
		public RuleCall getInstanceInitializationExpressionParserRuleCall_1() { return cInstanceInitializationExpressionParserRuleCall_1; }
	}

	public class InstanceInitializationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InstanceInitializationExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNewKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTupleAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTupleTupleParserRuleCall_1_0 = (RuleCall)cTupleAssignment_1.eContents().get(0);
		
		//InstanceInitializationExpression returns InstanceCreationExpression:
		//	"new" tuple=Tuple;
		@Override public ParserRule getRule() { return rule; }

		//"new" tuple=Tuple
		public Group getGroup() { return cGroup; }

		//"new"
		public Keyword getNewKeyword_0() { return cNewKeyword_0; }

		//tuple=Tuple
		public Assignment getTupleAssignment_1() { return cTupleAssignment_1; }

		//Tuple
		public RuleCall getTupleTupleParserRuleCall_1_0() { return cTupleTupleParserRuleCall_1_0; }
	}

	public class ExpressionStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpressionStatement");
		private final Assignment cExpressionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_0 = (RuleCall)cExpressionAssignment.eContents().get(0);
		
		/// * EXPRESSION STATEMENTS * / ExpressionStatement:
		//	expression=Expression;
		@Override public ParserRule getRule() { return rule; }

		//expression=Expression
		public Assignment getExpressionAssignment() { return cExpressionAssignment; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_0() { return cExpressionExpressionParserRuleCall_0; }
	}

	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNonFinalClausesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNonFinalClausesConcurrentClausesParserRuleCall_1_0 = (RuleCall)cNonFinalClausesAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cElseKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Keyword cIfKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cNonFinalClausesAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cNonFinalClausesConcurrentClausesParserRuleCall_2_2_0 = (RuleCall)cNonFinalClausesAssignment_2_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cElseKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cFinalClauseAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cFinalClauseBlockParserRuleCall_3_1_0 = (RuleCall)cFinalClauseAssignment_3_1.eContents().get(0);
		
		/// * IF STATEMENTS * / IfStatement:
		//	"if" nonFinalClauses+=ConcurrentClauses ("else" "if" nonFinalClauses+=ConcurrentClauses)* ("else"
		//	finalClause=Block)?;
		@Override public ParserRule getRule() { return rule; }

		//"if" nonFinalClauses+=ConcurrentClauses ("else" "if" nonFinalClauses+=ConcurrentClauses)* ("else" finalClause=Block)?
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//nonFinalClauses+=ConcurrentClauses
		public Assignment getNonFinalClausesAssignment_1() { return cNonFinalClausesAssignment_1; }

		//ConcurrentClauses
		public RuleCall getNonFinalClausesConcurrentClausesParserRuleCall_1_0() { return cNonFinalClausesConcurrentClausesParserRuleCall_1_0; }

		//("else" "if" nonFinalClauses+=ConcurrentClauses)*
		public Group getGroup_2() { return cGroup_2; }

		//"else"
		public Keyword getElseKeyword_2_0() { return cElseKeyword_2_0; }

		//"if"
		public Keyword getIfKeyword_2_1() { return cIfKeyword_2_1; }

		//nonFinalClauses+=ConcurrentClauses
		public Assignment getNonFinalClausesAssignment_2_2() { return cNonFinalClausesAssignment_2_2; }

		//ConcurrentClauses
		public RuleCall getNonFinalClausesConcurrentClausesParserRuleCall_2_2_0() { return cNonFinalClausesConcurrentClausesParserRuleCall_2_2_0; }

		//("else" finalClause=Block)?
		public Group getGroup_3() { return cGroup_3; }

		//"else"
		public Keyword getElseKeyword_3_0() { return cElseKeyword_3_0; }

		//finalClause=Block
		public Assignment getFinalClauseAssignment_3_1() { return cFinalClauseAssignment_3_1; }

		//Block
		public RuleCall getFinalClauseBlockParserRuleCall_3_1_0() { return cFinalClauseBlockParserRuleCall_3_1_0; }
	}

	public class ConcurrentClausesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConcurrentClauses");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cClauseAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cClauseNonFinalClauseParserRuleCall_0_0 = (RuleCall)cClauseAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cOrKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cIfKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cClauseAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cClauseNonFinalClauseParserRuleCall_1_2_0 = (RuleCall)cClauseAssignment_1_2.eContents().get(0);
		
		//ConcurrentClauses:
		//	clause+=NonFinalClause ("or" "if" clause+=NonFinalClause)*;
		@Override public ParserRule getRule() { return rule; }

		//clause+=NonFinalClause ("or" "if" clause+=NonFinalClause)*
		public Group getGroup() { return cGroup; }

		//clause+=NonFinalClause
		public Assignment getClauseAssignment_0() { return cClauseAssignment_0; }

		//NonFinalClause
		public RuleCall getClauseNonFinalClauseParserRuleCall_0_0() { return cClauseNonFinalClauseParserRuleCall_0_0; }

		//("or" "if" clause+=NonFinalClause)*
		public Group getGroup_1() { return cGroup_1; }

		//"or"
		public Keyword getOrKeyword_1_0() { return cOrKeyword_1_0; }

		//"if"
		public Keyword getIfKeyword_1_1() { return cIfKeyword_1_1; }

		//clause+=NonFinalClause
		public Assignment getClauseAssignment_1_2() { return cClauseAssignment_1_2; }

		//NonFinalClause
		public RuleCall getClauseNonFinalClauseParserRuleCall_1_2_0() { return cClauseNonFinalClauseParserRuleCall_1_2_0; }
	}

	public class NonFinalClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NonFinalClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionExpressionParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyBlockParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		
		//NonFinalClause:
		//	"(" condition=Expression ")" body=Block;
		@Override public ParserRule getRule() { return rule; }

		//"(" condition=Expression ")" body=Block
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//condition=Expression
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_1_0() { return cConditionExpressionParserRuleCall_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }

		//body=Block
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }

		//Block
		public RuleCall getBodyBlockParserRuleCall_3_0() { return cBodyBlockParserRuleCall_3_0; }
	}

	public class SwitchStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SwitchStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSwitchKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cNonDefaultClauseAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cNonDefaultClauseSwitchClauseParserRuleCall_5_0 = (RuleCall)cNonDefaultClauseAssignment_5.eContents().get(0);
		private final Assignment cDefaultClauseAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cDefaultClauseSwitchDefaultClauseParserRuleCall_6_0 = (RuleCall)cDefaultClauseAssignment_6.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		/// * SWITCH STATEMENTS * / SwitchStatement:
		//	"switch" "(" expression=Expression ")" "{" nonDefaultClause+=SwitchClause* defaultClause=SwitchDefaultClause? "}";
		@Override public ParserRule getRule() { return rule; }

		//"switch" "(" expression=Expression ")" "{" nonDefaultClause+=SwitchClause* defaultClause=SwitchDefaultClause? "}"
		public Group getGroup() { return cGroup; }

		//"switch"
		public Keyword getSwitchKeyword_0() { return cSwitchKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }

		//nonDefaultClause+=SwitchClause*
		public Assignment getNonDefaultClauseAssignment_5() { return cNonDefaultClauseAssignment_5; }

		//SwitchClause
		public RuleCall getNonDefaultClauseSwitchClauseParserRuleCall_5_0() { return cNonDefaultClauseSwitchClauseParserRuleCall_5_0; }

		//defaultClause=SwitchDefaultClause?
		public Assignment getDefaultClauseAssignment_6() { return cDefaultClauseAssignment_6; }

		//SwitchDefaultClause
		public RuleCall getDefaultClauseSwitchDefaultClauseParserRuleCall_6_0() { return cDefaultClauseSwitchDefaultClauseParserRuleCall_6_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}

	public class SwitchClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SwitchClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCaseAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCaseSwitchCaseParserRuleCall_0_0 = (RuleCall)cCaseAssignment_0.eContents().get(0);
		private final Assignment cCaseAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCaseSwitchCaseParserRuleCall_1_0 = (RuleCall)cCaseAssignment_1.eContents().get(0);
		private final Assignment cBlockAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBlockNonEmptyStatementSequenceParserRuleCall_2_0 = (RuleCall)cBlockAssignment_2.eContents().get(0);
		
		//SwitchClause:
		//	case+=SwitchCase case+=SwitchCase* block=NonEmptyStatementSequence;
		@Override public ParserRule getRule() { return rule; }

		//case+=SwitchCase case+=SwitchCase* block=NonEmptyStatementSequence
		public Group getGroup() { return cGroup; }

		//case+=SwitchCase
		public Assignment getCaseAssignment_0() { return cCaseAssignment_0; }

		//SwitchCase
		public RuleCall getCaseSwitchCaseParserRuleCall_0_0() { return cCaseSwitchCaseParserRuleCall_0_0; }

		//case+=SwitchCase*
		public Assignment getCaseAssignment_1() { return cCaseAssignment_1; }

		//SwitchCase
		public RuleCall getCaseSwitchCaseParserRuleCall_1_0() { return cCaseSwitchCaseParserRuleCall_1_0; }

		//block=NonEmptyStatementSequence
		public Assignment getBlockAssignment_2() { return cBlockAssignment_2; }

		//NonEmptyStatementSequence
		public RuleCall getBlockNonEmptyStatementSequenceParserRuleCall_2_0() { return cBlockNonEmptyStatementSequenceParserRuleCall_2_0; }
	}

	public class SwitchCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SwitchCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//SwitchCase returns Expression:
		//	"case" Expression ":";
		@Override public ParserRule getRule() { return rule; }

		//"case" Expression ":"
		public Group getGroup() { return cGroup; }

		//"case"
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
	}

	public class SwitchDefaultClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SwitchDefaultClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDefaultKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cNonEmptyStatementSequenceParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//SwitchDefaultClause returns Block:
		//	"default" ":" NonEmptyStatementSequence;
		@Override public ParserRule getRule() { return rule; }

		//"default" ":" NonEmptyStatementSequence
		public Group getGroup() { return cGroup; }

		//"default"
		public Keyword getDefaultKeyword_0() { return cDefaultKeyword_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//NonEmptyStatementSequence
		public RuleCall getNonEmptyStatementSequenceParserRuleCall_2() { return cNonEmptyStatementSequenceParserRuleCall_2; }
	}

	public class NonEmptyStatementSequenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NonEmptyStatementSequence");
		private final Assignment cStatementAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_0 = (RuleCall)cStatementAssignment.eContents().get(0);
		
		//NonEmptyStatementSequence returns Block:
		//	statement+=Statement+;
		@Override public ParserRule getRule() { return rule; }

		//statement+=Statement+
		public Assignment getStatementAssignment() { return cStatementAssignment; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_0() { return cStatementStatementParserRuleCall_0; }
	}

	public class WhileStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhileStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExpressionParserRuleCall_2_0 = (RuleCall)cConditionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBodyAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBodyBlockParserRuleCall_4_0 = (RuleCall)cBodyAssignment_4.eContents().get(0);
		
		/// * WHILE STATEMENTS * / WhileStatement:
		//	"while" "(" condition=Expression ")" body=Block;
		@Override public ParserRule getRule() { return rule; }

		//"while" "(" condition=Expression ")" body=Block
		public Group getGroup() { return cGroup; }

		//"while"
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//condition=Expression
		public Assignment getConditionAssignment_2() { return cConditionAssignment_2; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_2_0() { return cConditionExpressionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//body=Block
		public Assignment getBodyAssignment_4() { return cBodyAssignment_4; }

		//Block
		public RuleCall getBodyBlockParserRuleCall_4_0() { return cBodyBlockParserRuleCall_4_0; }
	}

	public class DoStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DoStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyBlockParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		private final Keyword cWhileKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cConditionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cConditionExpressionParserRuleCall_4_0 = (RuleCall)cConditionAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		/// * DO STATEMENTS * / DoStatement:
		//	"do" body=Block "while" "(" condition=Expression ")" ";";
		@Override public ParserRule getRule() { return rule; }

		//"do" body=Block "while" "(" condition=Expression ")" ";"
		public Group getGroup() { return cGroup; }

		//"do"
		public Keyword getDoKeyword_0() { return cDoKeyword_0; }

		//body=Block
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }

		//Block
		public RuleCall getBodyBlockParserRuleCall_1_0() { return cBodyBlockParserRuleCall_1_0; }

		//"while"
		public Keyword getWhileKeyword_2() { return cWhileKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//condition=Expression
		public Assignment getConditionAssignment_4() { return cConditionAssignment_4; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_4_0() { return cConditionExpressionParserRuleCall_4_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//";"
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
	}

	public class ForStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cInitializationAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cInitializationSimpleStatementParserRuleCall_2_0 = (RuleCall)cInitializationAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cConditionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cConditionExpressionParserRuleCall_4_0 = (RuleCall)cConditionAssignment_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cUpdateAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cUpdateSimpleStatementParserRuleCall_6_0 = (RuleCall)cUpdateAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cBodyAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cBodyBlockParserRuleCall_8_0 = (RuleCall)cBodyAssignment_8.eContents().get(0);
		
		/// * FOR STATEMENTS * / ForStatement:
		//	"for" "(" initialization=SimpleStatement ";" condition=Expression ";" update=SimpleStatement ")" body=Block;
		@Override public ParserRule getRule() { return rule; }

		//"for" "(" initialization=SimpleStatement ";" condition=Expression ";" update=SimpleStatement ")" body=Block
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//initialization=SimpleStatement
		public Assignment getInitializationAssignment_2() { return cInitializationAssignment_2; }

		//SimpleStatement
		public RuleCall getInitializationSimpleStatementParserRuleCall_2_0() { return cInitializationSimpleStatementParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }

		//condition=Expression
		public Assignment getConditionAssignment_4() { return cConditionAssignment_4; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_4_0() { return cConditionExpressionParserRuleCall_4_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }

		//update=SimpleStatement
		public Assignment getUpdateAssignment_6() { return cUpdateAssignment_6; }

		//SimpleStatement
		public RuleCall getUpdateSimpleStatementParserRuleCall_6_0() { return cUpdateSimpleStatementParserRuleCall_6_0; }

		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }

		//body=Block
		public Assignment getBodyAssignment_8() { return cBodyAssignment_8; }

		//Block
		public RuleCall getBodyBlockParserRuleCall_8_0() { return cBodyBlockParserRuleCall_8_0; }
	}

	public class ForEachStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ForEachStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cVariableDefinitionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVariableDefinitionLoopVariableDefinitionParserRuleCall_2_0 = (RuleCall)cVariableDefinitionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBodyAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBodyBlockParserRuleCall_4_0 = (RuleCall)cBodyAssignment_4.eContents().get(0);
		
		//ForEachStatement:
		//	"for" "(" variableDefinition=LoopVariableDefinition ")" body=Block;
		@Override public ParserRule getRule() { return rule; }

		//"for" "(" variableDefinition=LoopVariableDefinition ")" body=Block
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//variableDefinition=LoopVariableDefinition
		public Assignment getVariableDefinitionAssignment_2() { return cVariableDefinitionAssignment_2; }

		//LoopVariableDefinition
		public RuleCall getVariableDefinitionLoopVariableDefinitionParserRuleCall_2_0() { return cVariableDefinitionLoopVariableDefinitionParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//body=Block
		public Assignment getBodyAssignment_4() { return cBodyAssignment_4; }

		//Block
		public RuleCall getBodyBlockParserRuleCall_4_0() { return cBodyBlockParserRuleCall_4_0; }
	}

	public class LoopVariableDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LoopVariableDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLoopVariableAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cNameNameParserRuleCall_1_0_0 = (RuleCall)cNameAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Assignment cTypeAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cTypeTypeDeclarationParserRuleCall_1_1_0_0 = (RuleCall)cTypeAssignment_1_1_0.eContents().get(0);
		private final Assignment cNameAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cNameNameParserRuleCall_1_1_1_0 = (RuleCall)cNameAssignment_1_1_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		
		//LoopVariableDefinition returns Variable:
		//	{LoopVariable} (name=Name | type=TypeDeclaration name=Name) ":" expression=Expression;
		@Override public ParserRule getRule() { return rule; }

		//{LoopVariable} (name=Name | type=TypeDeclaration name=Name) ":" expression=Expression
		public Group getGroup() { return cGroup; }

		//{LoopVariable}
		public Action getLoopVariableAction_0() { return cLoopVariableAction_0; }

		//name=Name | type=TypeDeclaration name=Name
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//name=Name
		public Assignment getNameAssignment_1_0() { return cNameAssignment_1_0; }

		//Name
		public RuleCall getNameNameParserRuleCall_1_0_0() { return cNameNameParserRuleCall_1_0_0; }

		//type=TypeDeclaration name=Name
		public Group getGroup_1_1() { return cGroup_1_1; }

		//type=TypeDeclaration
		public Assignment getTypeAssignment_1_1_0() { return cTypeAssignment_1_1_0; }

		//TypeDeclaration
		public RuleCall getTypeTypeDeclarationParserRuleCall_1_1_0_0() { return cTypeTypeDeclarationParserRuleCall_1_1_0_0; }

		//name=Name
		public Assignment getNameAssignment_1_1_1() { return cNameAssignment_1_1_1; }

		//Name
		public RuleCall getNameNameParserRuleCall_1_1_1_0() { return cNameNameParserRuleCall_1_1_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//expression=Expression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_3_0() { return cExpressionExpressionParserRuleCall_3_0; }
	}

	public class BreakStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BreakStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBreakStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cBreakKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		/// * BREAK STATEMENTS * / BreakStatement:
		//	{BreakStatement} "break" ";";
		@Override public ParserRule getRule() { return rule; }

		//{BreakStatement} "break" ";"
		public Group getGroup() { return cGroup; }

		//{BreakStatement}
		public Action getBreakStatementAction_0() { return cBreakStatementAction_0; }

		//"break"
		public Keyword getBreakKeyword_1() { return cBreakKeyword_1; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class ReturnStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReturnStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cReturnStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cReturnKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// * RETURN STATEMENTS * / ReturnStatement:
		//	{ReturnStatement} "return" expression=Expression? ";";
		@Override public ParserRule getRule() { return rule; }

		//{ReturnStatement} "return" expression=Expression? ";"
		public Group getGroup() { return cGroup; }

		//{ReturnStatement}
		public Action getReturnStatementAction_0() { return cReturnStatementAction_0; }

		//"return"
		public Keyword getReturnKeyword_1() { return cReturnKeyword_1; }

		//expression=Expression?
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ClassifyStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClassifyStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cClassifyKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Assignment cFromListAssignment_2_0_0 = (Assignment)cGroup_2_0.eContents().get(0);
		private final RuleCall cFromListClassificationFromClauseParserRuleCall_2_0_0_0 = (RuleCall)cFromListAssignment_2_0_0.eContents().get(0);
		private final Assignment cToListAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final RuleCall cToListClassificationToClauseParserRuleCall_2_0_1_0 = (RuleCall)cToListAssignment_2_0_1.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Assignment cIsReclassifyAllAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cIsReclassifyAllReclassifyAllClauseParserRuleCall_2_1_0_0 = (RuleCall)cIsReclassifyAllAssignment_2_1_0.eContents().get(0);
		private final Assignment cToListAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cToListClassificationToClauseParserRuleCall_2_1_1_0 = (RuleCall)cToListAssignment_2_1_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// * CLASSIFY STATEMENTS * / ClassifyStatement:
		//	"classify" expression=Expression (fromList=ClassificationFromClause toList=ClassificationToClause? |
		//	isReclassifyAll?=ReclassifyAllClause? toList=ClassificationToClause) ";";
		@Override public ParserRule getRule() { return rule; }

		//"classify" expression=Expression (fromList=ClassificationFromClause toList=ClassificationToClause? |
		//isReclassifyAll?=ReclassifyAllClause? toList=ClassificationToClause) ";"
		public Group getGroup() { return cGroup; }

		//"classify"
		public Keyword getClassifyKeyword_0() { return cClassifyKeyword_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }

		//fromList=ClassificationFromClause toList=ClassificationToClause? | isReclassifyAll?=ReclassifyAllClause?
		//toList=ClassificationToClause
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//fromList=ClassificationFromClause toList=ClassificationToClause?
		public Group getGroup_2_0() { return cGroup_2_0; }

		//fromList=ClassificationFromClause
		public Assignment getFromListAssignment_2_0_0() { return cFromListAssignment_2_0_0; }

		//ClassificationFromClause
		public RuleCall getFromListClassificationFromClauseParserRuleCall_2_0_0_0() { return cFromListClassificationFromClauseParserRuleCall_2_0_0_0; }

		//toList=ClassificationToClause?
		public Assignment getToListAssignment_2_0_1() { return cToListAssignment_2_0_1; }

		//ClassificationToClause
		public RuleCall getToListClassificationToClauseParserRuleCall_2_0_1_0() { return cToListClassificationToClauseParserRuleCall_2_0_1_0; }

		//isReclassifyAll?=ReclassifyAllClause? toList=ClassificationToClause
		public Group getGroup_2_1() { return cGroup_2_1; }

		//isReclassifyAll?=ReclassifyAllClause?
		public Assignment getIsReclassifyAllAssignment_2_1_0() { return cIsReclassifyAllAssignment_2_1_0; }

		//ReclassifyAllClause
		public RuleCall getIsReclassifyAllReclassifyAllClauseParserRuleCall_2_1_0_0() { return cIsReclassifyAllReclassifyAllClauseParserRuleCall_2_1_0_0; }

		//toList=ClassificationToClause
		public Assignment getToListAssignment_2_1_1() { return cToListAssignment_2_1_1; }

		//ClassificationToClause
		public RuleCall getToListClassificationToClauseParserRuleCall_2_1_1_0() { return cToListClassificationToClauseParserRuleCall_2_1_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ClassificationFromClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClassificationFromClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFromKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cQualifiedNameListParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//ClassificationFromClause returns QualifiedNameList:
		//	"from" QualifiedNameList;
		@Override public ParserRule getRule() { return rule; }

		//"from" QualifiedNameList
		public Group getGroup() { return cGroup; }

		//"from"
		public Keyword getFromKeyword_0() { return cFromKeyword_0; }

		//QualifiedNameList
		public RuleCall getQualifiedNameListParserRuleCall_1() { return cQualifiedNameListParserRuleCall_1; }
	}

	public class ClassificationToClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClassificationToClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cToKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cQualifiedNameListParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//ClassificationToClause returns QualifiedNameList:
		//	"to" QualifiedNameList;
		@Override public ParserRule getRule() { return rule; }

		//"to" QualifiedNameList
		public Group getGroup() { return cGroup; }

		//"to"
		public Keyword getToKeyword_0() { return cToKeyword_0; }

		//QualifiedNameList
		public RuleCall getQualifiedNameListParserRuleCall_1() { return cQualifiedNameListParserRuleCall_1; }
	}

	public class ReclassifyAllClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReclassifyAllClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFromKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//ReclassifyAllClause:
		//	"from" "*";
		@Override public ParserRule getRule() { return rule; }

		//"from" "*"
		public Group getGroup() { return cGroup; }

		//"from"
		public Keyword getFromKeyword_0() { return cFromKeyword_0; }

		//"*"
		public Keyword getAsteriskKeyword_1() { return cAsteriskKeyword_1; }
	}

	public class QualifiedNameListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedNameList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameQualifiedNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNameQualifiedNameParserRuleCall_1_1_0 = (RuleCall)cNameAssignment_1_1.eContents().get(0);
		
		//QualifiedNameList:
		//	name+=QualifiedName ("," name+=QualifiedName)*;
		@Override public ParserRule getRule() { return rule; }

		//name+=QualifiedName ("," name+=QualifiedName)*
		public Group getGroup() { return cGroup; }

		//name+=QualifiedName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_0_0() { return cNameQualifiedNameParserRuleCall_0_0; }

		//("," name+=QualifiedName)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//name+=QualifiedName
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }

		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_1_1_0() { return cNameQualifiedNameParserRuleCall_1_1_0; }
	}

	public class SendSignalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SendSignalStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSendSignalStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSendKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSignalAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSignalExpressionParserRuleCall_2_0 = (RuleCall)cSignalAssignment_2.eContents().get(0);
		private final Keyword cToKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTargetAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTargetExpressionParserRuleCall_4_0 = (RuleCall)cTargetAssignment_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		/// ****************
		// * Send statement
		// ***************** / SendSignalStatement:
		//	{SendSignalStatement} "send" signal=Expression "to" target=Expression ";";
		@Override public ParserRule getRule() { return rule; }

		//{SendSignalStatement} "send" signal=Expression "to" target=Expression ";"
		public Group getGroup() { return cGroup; }

		//{SendSignalStatement}
		public Action getSendSignalStatementAction_0() { return cSendSignalStatementAction_0; }

		//"send"
		public Keyword getSendKeyword_1() { return cSendKeyword_1; }

		//signal=Expression
		public Assignment getSignalAssignment_2() { return cSignalAssignment_2; }

		//Expression
		public RuleCall getSignalExpressionParserRuleCall_2_0() { return cSignalExpressionParserRuleCall_2_0; }

		//"to"
		public Keyword getToKeyword_3() { return cToKeyword_3; }

		//target=Expression
		public Assignment getTargetAssignment_4() { return cTargetAssignment_4; }

		//Expression
		public RuleCall getTargetExpressionParserRuleCall_4_0() { return cTargetExpressionParserRuleCall_4_0; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}
	
	
	public class LinkOperationElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "LinkOperation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLinkEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLinkLinkKeyword_0_0 = (Keyword)cLinkEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cUnlinkEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cUnlinkUnlinkKeyword_1_0 = (Keyword)cUnlinkEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum LinkOperation:
		//	link | unlink;
		public EnumRule getRule() { return rule; }

		//link | unlink
		public Alternatives getAlternatives() { return cAlternatives; }

		//link
		public EnumLiteralDeclaration getLinkEnumLiteralDeclaration_0() { return cLinkEnumLiteralDeclaration_0; }

		//"link"
		public Keyword getLinkLinkKeyword_0_0() { return cLinkLinkKeyword_0_0; }

		//unlink
		public EnumLiteralDeclaration getUnlinkEnumLiteralDeclaration_1() { return cUnlinkEnumLiteralDeclaration_1; }

		//"unlink"
		public Keyword getUnlinkUnlinkKeyword_1_0() { return cUnlinkUnlinkKeyword_1_0; }
	}

	public class CollectionTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "CollectionType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSetEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSetSetKeyword_0_0 = (Keyword)cSetEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cBagEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cBagBagKeyword_1_0 = (Keyword)cBagEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cSequenceEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cSequenceSequenceKeyword_2_0 = (Keyword)cSequenceEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum CollectionType:
		//	set | bag | sequence;
		public EnumRule getRule() { return rule; }

		//set | bag | sequence
		public Alternatives getAlternatives() { return cAlternatives; }

		//set
		public EnumLiteralDeclaration getSetEnumLiteralDeclaration_0() { return cSetEnumLiteralDeclaration_0; }

		//"set"
		public Keyword getSetSetKeyword_0_0() { return cSetSetKeyword_0_0; }

		//bag
		public EnumLiteralDeclaration getBagEnumLiteralDeclaration_1() { return cBagEnumLiteralDeclaration_1; }

		//"bag"
		public Keyword getBagBagKeyword_1_0() { return cBagBagKeyword_1_0; }

		//sequence
		public EnumLiteralDeclaration getSequenceEnumLiteralDeclaration_2() { return cSequenceEnumLiteralDeclaration_2; }

		//"sequence"
		public Keyword getSequenceSequenceKeyword_2_0() { return cSequenceSequenceKeyword_2_0; }
	}

	public class AffixOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AffixOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cIncrementEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cIncrementPlusSignPlusSignKeyword_0_0 = (Keyword)cIncrementEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDecrementEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDecrementHyphenMinusHyphenMinusKeyword_1_0 = (Keyword)cDecrementEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum AffixOperator:
		//	increment="++" | decrement="--";
		public EnumRule getRule() { return rule; }

		//increment="++" | decrement="--"
		public Alternatives getAlternatives() { return cAlternatives; }

		//increment="++"
		public EnumLiteralDeclaration getIncrementEnumLiteralDeclaration_0() { return cIncrementEnumLiteralDeclaration_0; }

		//"++"
		public Keyword getIncrementPlusSignPlusSignKeyword_0_0() { return cIncrementPlusSignPlusSignKeyword_0_0; }

		//decrement="--"
		public EnumLiteralDeclaration getDecrementEnumLiteralDeclaration_1() { return cDecrementEnumLiteralDeclaration_1; }

		//"--"
		public Keyword getDecrementHyphenMinusHyphenMinusKeyword_1_0() { return cDecrementHyphenMinusHyphenMinusKeyword_1_0; }
	}

	public class NumericUnaryOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "NumericUnaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPlusEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPlusPlusSignKeyword_0_0 = (Keyword)cPlusEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMinusEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMinusHyphenMinusKeyword_1_0 = (Keyword)cMinusEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum NumericUnaryOperator:
		//	plus="+" | minus="-";
		public EnumRule getRule() { return rule; }

		//plus="+" | minus="-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//plus="+"
		public EnumLiteralDeclaration getPlusEnumLiteralDeclaration_0() { return cPlusEnumLiteralDeclaration_0; }

		//"+"
		public Keyword getPlusPlusSignKeyword_0_0() { return cPlusPlusSignKeyword_0_0; }

		//minus="-"
		public EnumLiteralDeclaration getMinusEnumLiteralDeclaration_1() { return cMinusEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getMinusHyphenMinusKeyword_1_0() { return cMinusHyphenMinusKeyword_1_0; }
	}

	public class ShiftOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ShiftOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cRightEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cRightGreaterThanSignGreaterThanSignKeyword_0_0 = (Keyword)cRightEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLeftEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLeftLessThanSignLessThanSignKeyword_1_0 = (Keyword)cLeftEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cTripleEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cTripleGreaterThanSignGreaterThanSignGreaterThanSignKeyword_2_0 = (Keyword)cTripleEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum ShiftOperator:
		//	right=">>" | left="<<" | triple=">>>";
		public EnumRule getRule() { return rule; }

		//right=">>" | left="<<" | triple=">>>"
		public Alternatives getAlternatives() { return cAlternatives; }

		//right=">>"
		public EnumLiteralDeclaration getRightEnumLiteralDeclaration_0() { return cRightEnumLiteralDeclaration_0; }

		//">>"
		public Keyword getRightGreaterThanSignGreaterThanSignKeyword_0_0() { return cRightGreaterThanSignGreaterThanSignKeyword_0_0; }

		//left="<<"
		public EnumLiteralDeclaration getLeftEnumLiteralDeclaration_1() { return cLeftEnumLiteralDeclaration_1; }

		//"<<"
		public Keyword getLeftLessThanSignLessThanSignKeyword_1_0() { return cLeftLessThanSignLessThanSignKeyword_1_0; }

		//triple=">>>"
		public EnumLiteralDeclaration getTripleEnumLiteralDeclaration_2() { return cTripleEnumLiteralDeclaration_2; }

		//">>>"
		public Keyword getTripleGreaterThanSignGreaterThanSignGreaterThanSignKeyword_2_0() { return cTripleGreaterThanSignGreaterThanSignGreaterThanSignKeyword_2_0; }
	}

	public class RelationalOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "RelationalOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cGreaterThanEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cGreaterThanGreaterThanSignKeyword_0_0 = (Keyword)cGreaterThanEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLesserThanEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLesserThanLessThanSignKeyword_1_0 = (Keyword)cLesserThanEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGreaterOrEqualsEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGreaterOrEqualsGreaterThanSignEqualsSignKeyword_2_0 = (Keyword)cGreaterOrEqualsEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLesserOrEqualsEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLesserOrEqualsLessThanSignEqualsSignKeyword_3_0 = (Keyword)cLesserOrEqualsEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum RelationalOperator:
		//	greaterThan=">" | lesserThan="<" | greaterOrEquals=">=" | lesserOrEquals="<=";
		public EnumRule getRule() { return rule; }

		//greaterThan=">" | lesserThan="<" | greaterOrEquals=">=" | lesserOrEquals="<="
		public Alternatives getAlternatives() { return cAlternatives; }

		//greaterThan=">"
		public EnumLiteralDeclaration getGreaterThanEnumLiteralDeclaration_0() { return cGreaterThanEnumLiteralDeclaration_0; }

		//">"
		public Keyword getGreaterThanGreaterThanSignKeyword_0_0() { return cGreaterThanGreaterThanSignKeyword_0_0; }

		//lesserThan="<"
		public EnumLiteralDeclaration getLesserThanEnumLiteralDeclaration_1() { return cLesserThanEnumLiteralDeclaration_1; }

		//"<"
		public Keyword getLesserThanLessThanSignKeyword_1_0() { return cLesserThanLessThanSignKeyword_1_0; }

		//greaterOrEquals=">="
		public EnumLiteralDeclaration getGreaterOrEqualsEnumLiteralDeclaration_2() { return cGreaterOrEqualsEnumLiteralDeclaration_2; }

		//">="
		public Keyword getGreaterOrEqualsGreaterThanSignEqualsSignKeyword_2_0() { return cGreaterOrEqualsGreaterThanSignEqualsSignKeyword_2_0; }

		//lesserOrEquals="<="
		public EnumLiteralDeclaration getLesserOrEqualsEnumLiteralDeclaration_3() { return cLesserOrEqualsEnumLiteralDeclaration_3; }

		//"<="
		public Keyword getLesserOrEqualsLessThanSignEqualsSignKeyword_3_0() { return cLesserOrEqualsLessThanSignEqualsSignKeyword_3_0; }
	}

	public class ClassificationOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ClassificationOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cInstanceofEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cInstanceofInstanceofKeyword_0_0 = (Keyword)cInstanceofEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cHastypeEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cHastypeHastypeKeyword_1_0 = (Keyword)cHastypeEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ClassificationOperator:
		//	instanceof | hastype;
		public EnumRule getRule() { return rule; }

		//instanceof | hastype
		public Alternatives getAlternatives() { return cAlternatives; }

		//instanceof
		public EnumLiteralDeclaration getInstanceofEnumLiteralDeclaration_0() { return cInstanceofEnumLiteralDeclaration_0; }

		//"instanceof"
		public Keyword getInstanceofInstanceofKeyword_0_0() { return cInstanceofInstanceofKeyword_0_0; }

		//hastype
		public EnumLiteralDeclaration getHastypeEnumLiteralDeclaration_1() { return cHastypeEnumLiteralDeclaration_1; }

		//"hastype"
		public Keyword getHastypeHastypeKeyword_1_0() { return cHastypeHastypeKeyword_1_0; }
	}

	public class EqualityOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "EqualityOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEqualsEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEqualsEqualsSignEqualsSignKeyword_0_0 = (Keyword)cEqualsEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNotEqualsEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNotEqualsExclamationMarkEqualsSignKeyword_1_0 = (Keyword)cNotEqualsEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum EqualityOperator:
		//	equals="==" | notEquals="!=";
		public EnumRule getRule() { return rule; }

		//equals="==" | notEquals="!="
		public Alternatives getAlternatives() { return cAlternatives; }

		//equals="=="
		public EnumLiteralDeclaration getEqualsEnumLiteralDeclaration_0() { return cEqualsEnumLiteralDeclaration_0; }

		//"=="
		public Keyword getEqualsEqualsSignEqualsSignKeyword_0_0() { return cEqualsEqualsSignEqualsSignKeyword_0_0; }

		//notEquals="!="
		public EnumLiteralDeclaration getNotEqualsEnumLiteralDeclaration_1() { return cNotEqualsEnumLiteralDeclaration_1; }

		//"!="
		public Keyword getNotEqualsExclamationMarkEqualsSignKeyword_1_0() { return cNotEqualsExclamationMarkEqualsSignKeyword_1_0; }
	}

	public class AssignmentOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AssignmentOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cAssignEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cAssignEqualsSignKeyword_0_0 = (Keyword)cAssignEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cIncrementAssignEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cIncrementAssignPlusSignEqualsSignKeyword_1_0 = (Keyword)cIncrementAssignEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDecrementAssignEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDecrementAssignHyphenMinusEqualsSignKeyword_2_0 = (Keyword)cDecrementAssignEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cMultiplyAssignEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cMultiplyAssignAsteriskEqualsSignKeyword_3_0 = (Keyword)cMultiplyAssignEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cDivisionAssignEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cDivisionAssignSolidusEqualsSignKeyword_4_0 = (Keyword)cDivisionAssignEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cModuloAssignEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cModuloAssignPercentSignEqualsSignKeyword_5_0 = (Keyword)cModuloAssignEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cAndAssignEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cAndAssignAmpersandEqualsSignKeyword_6_0 = (Keyword)cAndAssignEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cOrAssignEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cOrAssignVerticalLineEqualsSignKeyword_7_0 = (Keyword)cOrAssignEnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cXorAssignEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cXorAssignCircumflexAccentEqualsSignKeyword_8_0 = (Keyword)cXorAssignEnumLiteralDeclaration_8.eContents().get(0);
		private final EnumLiteralDeclaration cLeftShiftAssignEnumLiteralDeclaration_9 = (EnumLiteralDeclaration)cAlternatives.eContents().get(9);
		private final Keyword cLeftShiftAssignLessThanSignLessThanSignEqualsSignKeyword_9_0 = (Keyword)cLeftShiftAssignEnumLiteralDeclaration_9.eContents().get(0);
		private final EnumLiteralDeclaration cRightShiftAssignEnumLiteralDeclaration_10 = (EnumLiteralDeclaration)cAlternatives.eContents().get(10);
		private final Keyword cRightShiftAssignGreaterThanSignGreaterThanSignEqualsSignKeyword_10_0 = (Keyword)cRightShiftAssignEnumLiteralDeclaration_10.eContents().get(0);
		private final EnumLiteralDeclaration cTripleShiftAssignEnumLiteralDeclaration_11 = (EnumLiteralDeclaration)cAlternatives.eContents().get(11);
		private final Keyword cTripleShiftAssignGreaterThanSignGreaterThanSignGreaterThanSignEqualsSignKeyword_11_0 = (Keyword)cTripleShiftAssignEnumLiteralDeclaration_11.eContents().get(0);
		
		//enum AssignmentOperator:
		//	assign="=" | incrementAssign="+=" | decrementAssign="-=" | multiplyAssign="*=" | divisionAssign="/=" |
		//	moduloAssign="%=" | andAssign="&=" | orAssign="|=" | xorAssign="^=" | leftShiftAssign="<<=" | rightShiftAssign=">>="
		//	| tripleShiftAssign=">>>=";
		public EnumRule getRule() { return rule; }

		//assign="=" | incrementAssign="+=" | decrementAssign="-=" | multiplyAssign="*=" | divisionAssign="/=" | moduloAssign="%="
		//| andAssign="&=" | orAssign="|=" | xorAssign="^=" | leftShiftAssign="<<=" | rightShiftAssign=">>=" |
		//tripleShiftAssign=">>>="
		public Alternatives getAlternatives() { return cAlternatives; }

		//assign="="
		public EnumLiteralDeclaration getAssignEnumLiteralDeclaration_0() { return cAssignEnumLiteralDeclaration_0; }

		//"="
		public Keyword getAssignEqualsSignKeyword_0_0() { return cAssignEqualsSignKeyword_0_0; }

		//incrementAssign="+="
		public EnumLiteralDeclaration getIncrementAssignEnumLiteralDeclaration_1() { return cIncrementAssignEnumLiteralDeclaration_1; }

		//"+="
		public Keyword getIncrementAssignPlusSignEqualsSignKeyword_1_0() { return cIncrementAssignPlusSignEqualsSignKeyword_1_0; }

		//decrementAssign="-="
		public EnumLiteralDeclaration getDecrementAssignEnumLiteralDeclaration_2() { return cDecrementAssignEnumLiteralDeclaration_2; }

		//"-="
		public Keyword getDecrementAssignHyphenMinusEqualsSignKeyword_2_0() { return cDecrementAssignHyphenMinusEqualsSignKeyword_2_0; }

		//multiplyAssign="*="
		public EnumLiteralDeclaration getMultiplyAssignEnumLiteralDeclaration_3() { return cMultiplyAssignEnumLiteralDeclaration_3; }

		//"*="
		public Keyword getMultiplyAssignAsteriskEqualsSignKeyword_3_0() { return cMultiplyAssignAsteriskEqualsSignKeyword_3_0; }

		//divisionAssign="/="
		public EnumLiteralDeclaration getDivisionAssignEnumLiteralDeclaration_4() { return cDivisionAssignEnumLiteralDeclaration_4; }

		//"/="
		public Keyword getDivisionAssignSolidusEqualsSignKeyword_4_0() { return cDivisionAssignSolidusEqualsSignKeyword_4_0; }

		//moduloAssign="%="
		public EnumLiteralDeclaration getModuloAssignEnumLiteralDeclaration_5() { return cModuloAssignEnumLiteralDeclaration_5; }

		//"%="
		public Keyword getModuloAssignPercentSignEqualsSignKeyword_5_0() { return cModuloAssignPercentSignEqualsSignKeyword_5_0; }

		//andAssign="&="
		public EnumLiteralDeclaration getAndAssignEnumLiteralDeclaration_6() { return cAndAssignEnumLiteralDeclaration_6; }

		//"&="
		public Keyword getAndAssignAmpersandEqualsSignKeyword_6_0() { return cAndAssignAmpersandEqualsSignKeyword_6_0; }

		//orAssign="|="
		public EnumLiteralDeclaration getOrAssignEnumLiteralDeclaration_7() { return cOrAssignEnumLiteralDeclaration_7; }

		//"|="
		public Keyword getOrAssignVerticalLineEqualsSignKeyword_7_0() { return cOrAssignVerticalLineEqualsSignKeyword_7_0; }

		//xorAssign="^="
		public EnumLiteralDeclaration getXorAssignEnumLiteralDeclaration_8() { return cXorAssignEnumLiteralDeclaration_8; }

		//"^="
		public Keyword getXorAssignCircumflexAccentEqualsSignKeyword_8_0() { return cXorAssignCircumflexAccentEqualsSignKeyword_8_0; }

		//leftShiftAssign="<<="
		public EnumLiteralDeclaration getLeftShiftAssignEnumLiteralDeclaration_9() { return cLeftShiftAssignEnumLiteralDeclaration_9; }

		//"<<="
		public Keyword getLeftShiftAssignLessThanSignLessThanSignEqualsSignKeyword_9_0() { return cLeftShiftAssignLessThanSignLessThanSignEqualsSignKeyword_9_0; }

		//rightShiftAssign=">>="
		public EnumLiteralDeclaration getRightShiftAssignEnumLiteralDeclaration_10() { return cRightShiftAssignEnumLiteralDeclaration_10; }

		//">>="
		public Keyword getRightShiftAssignGreaterThanSignGreaterThanSignEqualsSignKeyword_10_0() { return cRightShiftAssignGreaterThanSignGreaterThanSignEqualsSignKeyword_10_0; }

		//tripleShiftAssign=">>>="
		public EnumLiteralDeclaration getTripleShiftAssignEnumLiteralDeclaration_11() { return cTripleShiftAssignEnumLiteralDeclaration_11; }

		//">>>="
		public Keyword getTripleShiftAssignGreaterThanSignGreaterThanSignGreaterThanSignEqualsSignKeyword_11_0() { return cTripleShiftAssignGreaterThanSignGreaterThanSignGreaterThanSignEqualsSignKeyword_11_0; }
	}
	
	private final StatementsElements pStatements;
	private final NameElements pName;
	private final QualifiedNameElements pQualifiedName;
	private final ExpressionElements pExpression;
	private final PrimaryExpressionElements pPrimaryExpression;
	private final BaseExpressionElements pBaseExpression;
	private final LiteralExpressionElements pLiteralExpression;
	private final BooleanLiteralExpressionElements pBooleanLiteralExpression;
	private final NaturalLiteralExpressionElements pNaturalLiteralExpression;
	private final RealLiteralExpressionElements pRealLiteralExpression;
	private final UnboundedLiteralExpressionElements pUnboundedLiteralExpression;
	private final StringLiteralExpressionElements pStringLiteralExpression;
	private final NameExpressionElements pNameExpression;
	private final ThisExpressionElements pThisExpression;
	private final ParenthesizedExpressionElements pParenthesizedExpression;
	private final PropertyAccessExpressionElements pPropertyAccessExpression;
	private final TupleElements pTuple;
	private final ExpressionListElements pExpressionList;
	private final NamedTupleExpressionListElements pNamedTupleExpressionList;
	private final NamedExpressionElements pNamedExpression;
	private final SuperInvocationExpressionElements pSuperInvocationExpression;
	private final InstanceCreationOrSequenceConstructionExpressionElements pInstanceCreationOrSequenceConstructionExpression;
	private final LinkOperationExpressionElements pLinkOperationExpression;
	private final LinkOperationElements unknownRuleLinkOperation;
	private final ClassExtentExpressionElements pClassExtentExpression;
	private final NullExpressionElements pNullExpression;
	private final CollectionLiteralExpressionElements pCollectionLiteralExpression;
	private final CollectionTypeElements unknownRuleCollectionType;
	private final TypeDeclarationElements pTypeDeclaration;
	private final IndexElements pIndex;
	private final PrefixExpressionElements pPrefixExpression;
	private final AffixOperatorElements unknownRuleAffixOperator;
	private final UnaryExpressionElements pUnaryExpression;
	private final PostfixOrCastExpressionElements pPostfixOrCastExpression;
	private final PostfixExpressionElements pPostfixExpression;
	private final NonPostfixNonCastUnaryExpressionElements pNonPostfixNonCastUnaryExpression;
	private final BooleanUnaryExpressionElements pBooleanUnaryExpression;
	private final BitStringUnaryExpressionElements pBitStringUnaryExpression;
	private final NumericUnaryExpressionElements pNumericUnaryExpression;
	private final NumericUnaryOperatorElements unknownRuleNumericUnaryOperator;
	private final IsolationExpressionElements pIsolationExpression;
	private final CastExpressionElements pCastExpression;
	private final CastCompletionElements pCastCompletion;
	private final MultiplicativeExpressionElements pMultiplicativeExpression;
	private final MultiplicativeOperatorElements pMultiplicativeOperator;
	private final AdditiveExpressionElements pAdditiveExpression;
	private final AdditiveOperatorElements pAdditiveOperator;
	private final ShiftExpressionElements pShiftExpression;
	private final ShiftOperatorElements unknownRuleShiftOperator;
	private final RelationalExpressionElements pRelationalExpression;
	private final RelationalOperatorElements unknownRuleRelationalOperator;
	private final ClassificationExpressionElements pClassificationExpression;
	private final ClassificationOperatorElements unknownRuleClassificationOperator;
	private final EqualityExpressionElements pEqualityExpression;
	private final EqualityOperatorElements unknownRuleEqualityOperator;
	private final AndExpressionElements pAndExpression;
	private final ExclusiveOrExpressionElements pExclusiveOrExpression;
	private final InclusiveOrExpressionElements pInclusiveOrExpression;
	private final ConditionalAndExpressionElements pConditionalAndExpression;
	private final ConditionalOrExpressionElements pConditionalOrExpression;
	private final ConditionalExpressionElements pConditionalExpression;
	private final AssignmentExpressionElements pAssignmentExpression;
	private final LeftHandSideElements pLeftHandSide;
	private final NameLeftHandSideElements pNameLeftHandSide;
	private final FeatureLeftHandSideElements pFeatureLeftHandSide;
	private final AssignmentOperatorElements unknownRuleAssignmentOperator;
	private final StatementElements pStatement;
	private final SimpleStatementElements pSimpleStatement;
	private final BlockElements pBlock;
	private final BlockStatementElements pBlockStatement;
	private final EmptyStatementElements pEmptyStatement;
	private final MultiplicityIndicatorElements pMultiplicityIndicator;
	private final VariableDeclarationElements pVariableDeclaration;
	private final LocalNameDeclarationStatementElements pLocalNameDeclarationStatement;
	private final InitializationExpressionElements pInitializationExpression;
	private final InstanceInitializationExpressionElements pInstanceInitializationExpression;
	private final ExpressionStatementElements pExpressionStatement;
	private final IfStatementElements pIfStatement;
	private final ConcurrentClausesElements pConcurrentClauses;
	private final NonFinalClauseElements pNonFinalClause;
	private final SwitchStatementElements pSwitchStatement;
	private final SwitchClauseElements pSwitchClause;
	private final SwitchCaseElements pSwitchCase;
	private final SwitchDefaultClauseElements pSwitchDefaultClause;
	private final NonEmptyStatementSequenceElements pNonEmptyStatementSequence;
	private final WhileStatementElements pWhileStatement;
	private final DoStatementElements pDoStatement;
	private final ForStatementElements pForStatement;
	private final ForEachStatementElements pForEachStatement;
	private final LoopVariableDefinitionElements pLoopVariableDefinition;
	private final BreakStatementElements pBreakStatement;
	private final ReturnStatementElements pReturnStatement;
	private final ClassifyStatementElements pClassifyStatement;
	private final ClassificationFromClauseElements pClassificationFromClause;
	private final ClassificationToClauseElements pClassificationToClause;
	private final ReclassifyAllClauseElements pReclassifyAllClause;
	private final QualifiedNameListElements pQualifiedNameList;
	private final SendSignalStatementElements pSendSignalStatement;
	private final TerminalRule tBOOLEAN_VALUE;
	private final TerminalRule tNATURAL_VALUE;
	private final TerminalRule tREAL_VALUE;
	private final TerminalRule tID;
	private final TerminalRule tUNRESTRICTED_NAME;
	private final TerminalRule tSTRING;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	
	private final Grammar grammar;

	@Inject
	public ReducedAlfLanguageGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pStatements = new StatementsElements();
		this.pName = new NameElements();
		this.pQualifiedName = new QualifiedNameElements();
		this.pExpression = new ExpressionElements();
		this.pPrimaryExpression = new PrimaryExpressionElements();
		this.pBaseExpression = new BaseExpressionElements();
		this.pLiteralExpression = new LiteralExpressionElements();
		this.pBooleanLiteralExpression = new BooleanLiteralExpressionElements();
		this.pNaturalLiteralExpression = new NaturalLiteralExpressionElements();
		this.pRealLiteralExpression = new RealLiteralExpressionElements();
		this.pUnboundedLiteralExpression = new UnboundedLiteralExpressionElements();
		this.pStringLiteralExpression = new StringLiteralExpressionElements();
		this.pNameExpression = new NameExpressionElements();
		this.pThisExpression = new ThisExpressionElements();
		this.pParenthesizedExpression = new ParenthesizedExpressionElements();
		this.pPropertyAccessExpression = new PropertyAccessExpressionElements();
		this.pTuple = new TupleElements();
		this.pExpressionList = new ExpressionListElements();
		this.pNamedTupleExpressionList = new NamedTupleExpressionListElements();
		this.pNamedExpression = new NamedExpressionElements();
		this.pSuperInvocationExpression = new SuperInvocationExpressionElements();
		this.pInstanceCreationOrSequenceConstructionExpression = new InstanceCreationOrSequenceConstructionExpressionElements();
		this.pLinkOperationExpression = new LinkOperationExpressionElements();
		this.unknownRuleLinkOperation = new LinkOperationElements();
		this.pClassExtentExpression = new ClassExtentExpressionElements();
		this.pNullExpression = new NullExpressionElements();
		this.pCollectionLiteralExpression = new CollectionLiteralExpressionElements();
		this.unknownRuleCollectionType = new CollectionTypeElements();
		this.pTypeDeclaration = new TypeDeclarationElements();
		this.pIndex = new IndexElements();
		this.pPrefixExpression = new PrefixExpressionElements();
		this.unknownRuleAffixOperator = new AffixOperatorElements();
		this.pUnaryExpression = new UnaryExpressionElements();
		this.pPostfixOrCastExpression = new PostfixOrCastExpressionElements();
		this.pPostfixExpression = new PostfixExpressionElements();
		this.pNonPostfixNonCastUnaryExpression = new NonPostfixNonCastUnaryExpressionElements();
		this.pBooleanUnaryExpression = new BooleanUnaryExpressionElements();
		this.pBitStringUnaryExpression = new BitStringUnaryExpressionElements();
		this.pNumericUnaryExpression = new NumericUnaryExpressionElements();
		this.unknownRuleNumericUnaryOperator = new NumericUnaryOperatorElements();
		this.pIsolationExpression = new IsolationExpressionElements();
		this.pCastExpression = new CastExpressionElements();
		this.pCastCompletion = new CastCompletionElements();
		this.pMultiplicativeExpression = new MultiplicativeExpressionElements();
		this.pMultiplicativeOperator = new MultiplicativeOperatorElements();
		this.pAdditiveExpression = new AdditiveExpressionElements();
		this.pAdditiveOperator = new AdditiveOperatorElements();
		this.pShiftExpression = new ShiftExpressionElements();
		this.unknownRuleShiftOperator = new ShiftOperatorElements();
		this.pRelationalExpression = new RelationalExpressionElements();
		this.unknownRuleRelationalOperator = new RelationalOperatorElements();
		this.pClassificationExpression = new ClassificationExpressionElements();
		this.unknownRuleClassificationOperator = new ClassificationOperatorElements();
		this.pEqualityExpression = new EqualityExpressionElements();
		this.unknownRuleEqualityOperator = new EqualityOperatorElements();
		this.pAndExpression = new AndExpressionElements();
		this.pExclusiveOrExpression = new ExclusiveOrExpressionElements();
		this.pInclusiveOrExpression = new InclusiveOrExpressionElements();
		this.pConditionalAndExpression = new ConditionalAndExpressionElements();
		this.pConditionalOrExpression = new ConditionalOrExpressionElements();
		this.pConditionalExpression = new ConditionalExpressionElements();
		this.pAssignmentExpression = new AssignmentExpressionElements();
		this.pLeftHandSide = new LeftHandSideElements();
		this.pNameLeftHandSide = new NameLeftHandSideElements();
		this.pFeatureLeftHandSide = new FeatureLeftHandSideElements();
		this.unknownRuleAssignmentOperator = new AssignmentOperatorElements();
		this.pStatement = new StatementElements();
		this.pSimpleStatement = new SimpleStatementElements();
		this.pBlock = new BlockElements();
		this.pBlockStatement = new BlockStatementElements();
		this.pEmptyStatement = new EmptyStatementElements();
		this.pMultiplicityIndicator = new MultiplicityIndicatorElements();
		this.pVariableDeclaration = new VariableDeclarationElements();
		this.pLocalNameDeclarationStatement = new LocalNameDeclarationStatementElements();
		this.pInitializationExpression = new InitializationExpressionElements();
		this.pInstanceInitializationExpression = new InstanceInitializationExpressionElements();
		this.pExpressionStatement = new ExpressionStatementElements();
		this.pIfStatement = new IfStatementElements();
		this.pConcurrentClauses = new ConcurrentClausesElements();
		this.pNonFinalClause = new NonFinalClauseElements();
		this.pSwitchStatement = new SwitchStatementElements();
		this.pSwitchClause = new SwitchClauseElements();
		this.pSwitchCase = new SwitchCaseElements();
		this.pSwitchDefaultClause = new SwitchDefaultClauseElements();
		this.pNonEmptyStatementSequence = new NonEmptyStatementSequenceElements();
		this.pWhileStatement = new WhileStatementElements();
		this.pDoStatement = new DoStatementElements();
		this.pForStatement = new ForStatementElements();
		this.pForEachStatement = new ForEachStatementElements();
		this.pLoopVariableDefinition = new LoopVariableDefinitionElements();
		this.pBreakStatement = new BreakStatementElements();
		this.pReturnStatement = new ReturnStatementElements();
		this.pClassifyStatement = new ClassifyStatementElements();
		this.pClassificationFromClause = new ClassificationFromClauseElements();
		this.pClassificationToClause = new ClassificationToClauseElements();
		this.pReclassifyAllClause = new ReclassifyAllClauseElements();
		this.pQualifiedNameList = new QualifiedNameListElements();
		this.pSendSignalStatement = new SendSignalStatementElements();
		this.tBOOLEAN_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLEAN_VALUE");
		this.tNATURAL_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NATURAL_VALUE");
		this.tREAL_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "REAL_VALUE");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID");
		this.tUNRESTRICTED_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "UNRESTRICTED_NAME");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("com.incquerylabs.uml.ralf.ReducedAlfLanguage".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	/// **
	// * TOP LEVEL ELEMENT
	// * / Statements:
	//	statement+=Statement*;
	public StatementsElements getStatementsAccess() {
		return pStatements;
	}
	
	public ParserRule getStatementsRule() {
		return getStatementsAccess().getRule();
	}

	/// ***************
	// * NAMES        *
	// *************** / Name:
	//	ID | UNRESTRICTED_NAME;
	public NameElements getNameAccess() {
		return pName;
	}
	
	public ParserRule getNameRule() {
		return getNameAccess().getRule();
	}

	//QualifiedName:
	//	Name ("::" Name)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}

	/// ***************
	// * EXPRESSIONS *
	// *************** / Expression:
	//	AssignmentExpression | ConditionalExpression;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	/// * PRIMARY EXPRESSIONS * / PrimaryExpression returns Expression:
	//	BaseExpression ({FeatureInvocationExpression.context=current} ("." | isStatic?="::") operation=[uml::Operation|Name]
	//	parameters=Tuple | {PropertyAccessExpression.context=current} "." property=[uml::Property|Name] |
	//	{AssociationAccessExpression.context=current} "->" association=[uml::Property|Name] | //    {ExtentOrExpression.nonNameExpression = current} '->' 
	//	//      ( {SequenceOperationExpression.primary = current} operation = [uml::Operation|QualifiedName] tuple = Tuple
	//	//      // CHANGE: Made SequenceExpansionExpression concrete.
	//	//      | {SequenceExpansionExpression.primary = current} operation = ID variable = Name '(' argument = Expression ')'
	//	//      ) | 
	//	{SequenceAccessExpression.primary=current} index=Index)*;
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return pPrimaryExpression;
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	//BaseExpression returns Expression:
	//	LiteralExpression | CollectionLiteralExpression | ThisExpression | SuperInvocationExpression |
	//	InstanceCreationOrSequenceConstructionExpression | ClassExtentExpression | LinkOperationExpression | NullExpression | //  SequenceOperationOrReductionOrExpansionExpression |
	//	//    BehaviorInvocationExpression |
	//	NameExpression | ParenthesizedExpression;
	public BaseExpressionElements getBaseExpressionAccess() {
		return pBaseExpression;
	}
	
	public ParserRule getBaseExpressionRule() {
		return getBaseExpressionAccess().getRule();
	}

	/// * LITERAL EXPRESSIONS * / LiteralExpression:
	//	BooleanLiteralExpression | NaturalLiteralExpression | RealLiteralExpression | UnboundedLiteralExpression |
	//	StringLiteralExpression;
	public LiteralExpressionElements getLiteralExpressionAccess() {
		return pLiteralExpression;
	}
	
	public ParserRule getLiteralExpressionRule() {
		return getLiteralExpressionAccess().getRule();
	}

	//BooleanLiteralExpression:
	//	value=BOOLEAN_VALUE;
	public BooleanLiteralExpressionElements getBooleanLiteralExpressionAccess() {
		return pBooleanLiteralExpression;
	}
	
	public ParserRule getBooleanLiteralExpressionRule() {
		return getBooleanLiteralExpressionAccess().getRule();
	}

	//NaturalLiteralExpression:
	//	value=NATURAL_VALUE;
	public NaturalLiteralExpressionElements getNaturalLiteralExpressionAccess() {
		return pNaturalLiteralExpression;
	}
	
	public ParserRule getNaturalLiteralExpressionRule() {
		return getNaturalLiteralExpressionAccess().getRule();
	}

	//RealLiteralExpression:
	//	value=REAL_VALUE;
	public RealLiteralExpressionElements getRealLiteralExpressionAccess() {
		return pRealLiteralExpression;
	}
	
	public ParserRule getRealLiteralExpressionRule() {
		return getRealLiteralExpressionAccess().getRule();
	}

	//UnboundedLiteralExpression:
	//	{UnboundedLiteralExpression} value="*";
	public UnboundedLiteralExpressionElements getUnboundedLiteralExpressionAccess() {
		return pUnboundedLiteralExpression;
	}
	
	public ParserRule getUnboundedLiteralExpressionRule() {
		return getUnboundedLiteralExpressionAccess().getRule();
	}

	//StringLiteralExpression:
	//	value=STRING;
	public StringLiteralExpressionElements getStringLiteralExpressionAccess() {
		return pStringLiteralExpression;
	}
	
	public ParserRule getStringLiteralExpressionRule() {
		return getStringLiteralExpressionAccess().getRule();
	}

	/// * Name EXPRESSIONS * / NameExpression:
	//	reference=[uml::NamedElement|QualifiedName];
	public NameExpressionElements getNameExpressionAccess() {
		return pNameExpression;
	}
	
	public ParserRule getNameExpressionRule() {
		return getNameExpressionAccess().getRule();
	}

	/// * THIS EXPRESSIONS * / ThisExpression returns Expression:
	//	{FeatureInvocationExpression} "this" tuple=Tuple | {ThisExpression} "this";
	public ThisExpressionElements getThisExpressionAccess() {
		return pThisExpression;
	}
	
	public ParserRule getThisExpressionRule() {
		return getThisExpressionAccess().getRule();
	}

	/// * PARENTHESIZED EXPRESSIONS * / ParenthesizedExpression returns Expression:
	//	"(" Expression ")";
	public ParenthesizedExpressionElements getParenthesizedExpressionAccess() {
		return pParenthesizedExpression;
	}
	
	public ParserRule getParenthesizedExpressionRule() {
		return getParenthesizedExpressionAccess().getRule();
	}

	/// * PROPERTY ACCESS EXPRESSIONS * / // At this point in case of affix and postfix ++/-- operators, only variable names and properties can be used
	//// Property chaining is not supported at this time
	//// TODO: use primary expressions and filter using expression types
	//PropertyAccessExpression:
	//	context=PrimaryExpression "." property=[uml::Property|Name];
	public PropertyAccessExpressionElements getPropertyAccessExpressionAccess() {
		return pPropertyAccessExpression;
	}
	
	public ParserRule getPropertyAccessExpressionRule() {
		return getPropertyAccessExpressionAccess().getRule();
	}

	////FeatureReference :
	////  expression = PrimaryExpression // '.' nameBinding = NameBinding
	////;
	////FeatureTargetExpression returns Expression :
	////  NonNamePrimaryExpression | NameTargetExpression
	////;
	////
	////NameTargetExpression returns NameExpression :
	////  name = ColonQualifiedName
	////;
	/// * INVOCATION EXPRESSIONS * / //
	////BehaviorInvocationExpression :
	////  target = [uml::Behavior|QualifiedName] tuple = Tuple
	////;
	//Tuple:
	//	{ExpressionList} "(" ")" | "(" (NamedTupleExpressionList | ExpressionList) ")";
	public TupleElements getTupleAccess() {
		return pTuple;
	}
	
	public ParserRule getTupleRule() {
		return getTupleAccess().getRule();
	}

	//ExpressionList:
	//	{ExpressionList} (expressions+=Expression ("," expressions+=Expression)*)?;
	public ExpressionListElements getExpressionListAccess() {
		return pExpressionList;
	}
	
	public ParserRule getExpressionListRule() {
		return getExpressionListAccess().getRule();
	}

	//NamedTupleExpressionList returns NamedTuple:
	//	expressions+=NamedExpression ("," expressions+=NamedExpression)*;
	public NamedTupleExpressionListElements getNamedTupleExpressionListAccess() {
		return pNamedTupleExpressionList;
	}
	
	public ParserRule getNamedTupleExpressionListRule() {
		return getNamedTupleExpressionListAccess().getRule();
	}

	//NamedExpression:
	//	name=Name "=>" expression=Expression;
	public NamedExpressionElements getNamedExpressionAccess() {
		return pNamedExpression;
	}
	
	public ParserRule getNamedExpressionRule() {
		return getNamedExpressionAccess().getRule();
	}

	//SuperInvocationExpression:
	//	"super" ("." target=[uml::Operation|QualifiedName])? tuple=Tuple;
	public SuperInvocationExpressionElements getSuperInvocationExpressionAccess() {
		return pSuperInvocationExpression;
	}
	
	public ParserRule getSuperInvocationExpressionRule() {
		return getSuperInvocationExpressionAccess().getRule();
	}

	/// * INSTANCE CREATION EXPRESSIONS * / InstanceCreationOrSequenceConstructionExpression returns Expression:
	//	{InstanceCreationExpression} "new" instance=[uml::Classifier|QualifiedName] tuple=Tuple;
	public InstanceCreationOrSequenceConstructionExpressionElements getInstanceCreationOrSequenceConstructionExpressionAccess() {
		return pInstanceCreationOrSequenceConstructionExpression;
	}
	
	public ParserRule getInstanceCreationOrSequenceConstructionExpressionRule() {
		return getInstanceCreationOrSequenceConstructionExpressionAccess().getRule();
	}

	/// * LINK OPERATION EXPRESSIONS * / LinkOperationExpression:
	//	association=[uml::Association|QualifiedName] "::" operation=LinkOperation tuple=Tuple;
	public LinkOperationExpressionElements getLinkOperationExpressionAccess() {
		return pLinkOperationExpression;
	}
	
	public ParserRule getLinkOperationExpressionRule() {
		return getLinkOperationExpressionAccess().getRule();
	}

	//enum LinkOperation:
	//	link | unlink;
	public LinkOperationElements getLinkOperationAccess() {
		return unknownRuleLinkOperation;
	}
	
	public EnumRule getLinkOperationRule() {
		return getLinkOperationAccess().getRule();
	}

	/// * CLASS EXTENT EXPRESSIONS * / ClassExtentExpression:
	//	class=[uml::Class|QualifiedName] "::" "instances" "(" ")";
	public ClassExtentExpressionElements getClassExtentExpressionAccess() {
		return pClassExtentExpression;
	}
	
	public ParserRule getClassExtentExpressionRule() {
		return getClassExtentExpressionAccess().getRule();
	}

	/// * NULL EXPRESSION * / NullExpression:
	//	{NullExpression} "null";
	public NullExpressionElements getNullExpressionAccess() {
		return pNullExpression;
	}
	
	public ParserRule getNullExpressionRule() {
		return getNullExpressionAccess().getRule();
	}

	/// * SEQUENCE CONSTRUCTION EXPRESSIONS * / CollectionLiteralExpression: //    {RangeCollectionExpression}
	////    collectionType = CollectionType '<' typeDeclaration = TypeDeclaration '>' '{' ( range = SequenceRange)? '}' |
	//	{ElementCollectionExpression} (collectionType=CollectionType "<" typeDeclaration=TypeDeclaration ">")? "{"
	//	elements=ExpressionList? "}";
	public CollectionLiteralExpressionElements getCollectionLiteralExpressionAccess() {
		return pCollectionLiteralExpression;
	}
	
	public ParserRule getCollectionLiteralExpressionRule() {
		return getCollectionLiteralExpressionAccess().getRule();
	}

	//enum CollectionType:
	//	set | bag | sequence;
	public CollectionTypeElements getCollectionTypeAccess() {
		return unknownRuleCollectionType;
	}
	
	public EnumRule getCollectionTypeRule() {
		return getCollectionTypeAccess().getRule();
	}

	////TODO define collection types as well
	//TypeDeclaration: / *isAny ?= 'any' | * / type=[uml::Type|QualifiedName];
	public TypeDeclarationElements getTypeDeclarationAccess() {
		return pTypeDeclaration;
	}
	
	public ParserRule getTypeDeclarationRule() {
		return getTypeDeclarationAccess().getRule();
	}

	////SequenceRange :
	////  rangeLower = Expression '..' rangeUpper = Expression
	////;
	/// * SEQUENCE ACCESS EXPRESSIONS * / Index returns Expression:
	//	"[" Expression "]";
	public IndexElements getIndexAccess() {
		return pIndex;
	}
	
	public ParserRule getIndexRule() {
		return getIndexAccess().getRule();
	}

	/// * SEQUENCE OPERATION, REDUCTION AND EXPANSION EXPRESSIONS * / // NOTE: This only covers the case when the primary is a class extent shorthand.
	////SequenceOperationOrReductionOrExpansionExpression returns Expression :
	////  {ExtentOrExpression} name = / *PotentiallyAmbiguous* /QualifiedName '->' 
	////    ( {SequenceOperationExpression.primary = current} operation = [uml::Operation|QualifiedName] tuple = Tuple 
	////    // CHANGE: Made SequenceExpansionExpression concrete.
	////    | {SequenceExpansionExpression.primary = current} operation = ID variable = Name '(' argument = Expression ')'
	////    )
	////;
	/// * INCREMENT OR DECREMENT EXPRESSIONS * / PrefixExpression returns Expression: // CHANGE: Added operator to IncrementOrDecrementExpression in the metamodel.
	//	{PrefixExpression} operator=AffixOperator operand=LeftHandSide;
	public PrefixExpressionElements getPrefixExpressionAccess() {
		return pPrefixExpression;
	}
	
	public ParserRule getPrefixExpressionRule() {
		return getPrefixExpressionAccess().getRule();
	}

	//enum AffixOperator:
	//	increment="++" | decrement="--";
	public AffixOperatorElements getAffixOperatorAccess() {
		return unknownRuleAffixOperator;
	}
	
	public EnumRule getAffixOperatorRule() {
		return getAffixOperatorAccess().getRule();
	}

	/// * UNARY EXPRESSIONS * / UnaryExpression returns Expression:
	//	PostfixOrCastExpression | NonPostfixNonCastUnaryExpression | PrefixExpression;
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return pUnaryExpression;
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}

	//PostfixOrCastExpression returns Expression:
	//	PostfixExpression | CastExpression | PrimaryExpression;
	public PostfixOrCastExpressionElements getPostfixOrCastExpressionAccess() {
		return pPostfixOrCastExpression;
	}
	
	public ParserRule getPostfixOrCastExpressionRule() {
		return getPostfixOrCastExpressionAccess().getRule();
	}

	//PostfixExpression returns Expression:
	//	{PostfixExpression} operand=LeftHandSide operator=AffixOperator;
	public PostfixExpressionElements getPostfixExpressionAccess() {
		return pPostfixExpression;
	}
	
	public ParserRule getPostfixExpressionRule() {
		return getPostfixExpressionAccess().getRule();
	}

	//NonPostfixNonCastUnaryExpression returns Expression: //PrefixExpression | 
	//	NumericUnaryExpression | BooleanUnaryExpression | BitStringUnaryExpression | IsolationExpression;
	public NonPostfixNonCastUnaryExpressionElements getNonPostfixNonCastUnaryExpressionAccess() {
		return pNonPostfixNonCastUnaryExpression;
	}
	
	public ParserRule getNonPostfixNonCastUnaryExpressionRule() {
		return getNonPostfixNonCastUnaryExpressionAccess().getRule();
	}

	//BooleanUnaryExpression:
	//	operator="!" operand=UnaryExpression;
	public BooleanUnaryExpressionElements getBooleanUnaryExpressionAccess() {
		return pBooleanUnaryExpression;
	}
	
	public ParserRule getBooleanUnaryExpressionRule() {
		return getBooleanUnaryExpressionAccess().getRule();
	}

	//BitStringUnaryExpression:
	//	operator="~" operand=UnaryExpression;
	public BitStringUnaryExpressionElements getBitStringUnaryExpressionAccess() {
		return pBitStringUnaryExpression;
	}
	
	public ParserRule getBitStringUnaryExpressionRule() {
		return getBitStringUnaryExpressionAccess().getRule();
	}

	//NumericUnaryExpression:
	//	operator=NumericUnaryOperator operand=(PostfixOrCastExpression | NonPostfixNonCastUnaryExpression) |
	//	operator=NumericUnaryOperator "(" operand=PrefixExpression ")";
	public NumericUnaryExpressionElements getNumericUnaryExpressionAccess() {
		return pNumericUnaryExpression;
	}
	
	public ParserRule getNumericUnaryExpressionRule() {
		return getNumericUnaryExpressionAccess().getRule();
	}

	//enum NumericUnaryOperator:
	//	plus="+" | minus="-";
	public NumericUnaryOperatorElements getNumericUnaryOperatorAccess() {
		return unknownRuleNumericUnaryOperator;
	}
	
	public EnumRule getNumericUnaryOperatorRule() {
		return getNumericUnaryOperatorAccess().getRule();
	}

	//IsolationExpression:
	//	operator="$" operand=UnaryExpression;
	public IsolationExpressionElements getIsolationExpressionAccess() {
		return pIsolationExpression;
	}
	
	public ParserRule getIsolationExpressionRule() {
		return getIsolationExpressionAccess().getRule();
	}

	//CastExpression:
	//	"(" type=TypeDeclaration ")" operand=CastCompletion;
	public CastExpressionElements getCastExpressionAccess() {
		return pCastExpression;
	}
	
	public ParserRule getCastExpressionRule() {
		return getCastExpressionAccess().getRule();
	}

	//CastCompletion returns Expression:
	//	PostfixOrCastExpression | BooleanUnaryExpression | BitStringUnaryExpression | IsolationExpression;
	public CastCompletionElements getCastCompletionAccess() {
		return pCastCompletion;
	}
	
	public ParserRule getCastCompletionRule() {
		return getCastCompletionAccess().getRule();
	}

	/// * ARITHMETIC EXPRESSIONS * / MultiplicativeExpression returns Expression:
	//	UnaryExpression ({ArithmeticExpression.operand1=current} operator=MultiplicativeOperator operand2=UnaryExpression)*;
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return pMultiplicativeExpression;
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}

	//MultiplicativeOperator:
	//	"*" | "/" | "%";
	public MultiplicativeOperatorElements getMultiplicativeOperatorAccess() {
		return pMultiplicativeOperator;
	}
	
	public ParserRule getMultiplicativeOperatorRule() {
		return getMultiplicativeOperatorAccess().getRule();
	}

	//AdditiveExpression returns Expression:
	//	MultiplicativeExpression ({ArithmeticExpression.operand1=current} operator=AdditiveOperator
	//	operand2=MultiplicativeExpression)*;
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return pAdditiveExpression;
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}

	//AdditiveOperator:
	//	"+" | "-";
	public AdditiveOperatorElements getAdditiveOperatorAccess() {
		return pAdditiveOperator;
	}
	
	public ParserRule getAdditiveOperatorRule() {
		return getAdditiveOperatorAccess().getRule();
	}

	/// * SHIFT EXPRESSIONS * / ShiftExpression returns Expression:
	//	AdditiveExpression ({ShiftExpression.operand1=current} operator=ShiftOperator operand2=AdditiveExpression)*;
	public ShiftExpressionElements getShiftExpressionAccess() {
		return pShiftExpression;
	}
	
	public ParserRule getShiftExpressionRule() {
		return getShiftExpressionAccess().getRule();
	}

	//enum ShiftOperator:
	//	right=">>" | left="<<" | triple=">>>";
	public ShiftOperatorElements getShiftOperatorAccess() {
		return unknownRuleShiftOperator;
	}
	
	public EnumRule getShiftOperatorRule() {
		return getShiftOperatorAccess().getRule();
	}

	/// * RELATIONAL EXPRESSIONS * / RelationalExpression returns Expression:
	//	ShiftExpression ({RelationalExpression.operand1=current} operator=RelationalOperator operand2=ShiftExpression)?;
	public RelationalExpressionElements getRelationalExpressionAccess() {
		return pRelationalExpression;
	}
	
	public ParserRule getRelationalExpressionRule() {
		return getRelationalExpressionAccess().getRule();
	}

	//enum RelationalOperator:
	//	greaterThan=">" | lesserThan="<" | greaterOrEquals=">=" | lesserOrEquals="<=";
	public RelationalOperatorElements getRelationalOperatorAccess() {
		return unknownRuleRelationalOperator;
	}
	
	public EnumRule getRelationalOperatorRule() {
		return getRelationalOperatorAccess().getRule();
	}

	/// * CLASSIFICATION EXPRESSIONS * / ClassificationExpression returns Expression:
	//	RelationalExpression ({ClassificationExpression.operand=current} operator=ClassificationOperator
	//	type=[uml::Class|QualifiedName])?;
	public ClassificationExpressionElements getClassificationExpressionAccess() {
		return pClassificationExpression;
	}
	
	public ParserRule getClassificationExpressionRule() {
		return getClassificationExpressionAccess().getRule();
	}

	//enum ClassificationOperator:
	//	instanceof | hastype;
	public ClassificationOperatorElements getClassificationOperatorAccess() {
		return unknownRuleClassificationOperator;
	}
	
	public EnumRule getClassificationOperatorRule() {
		return getClassificationOperatorAccess().getRule();
	}

	/// * EQUALITY EXPRESSIONS * / EqualityExpression returns Expression:
	//	ClassificationExpression ({EqualityExpression.operand1=current} operator=EqualityOperator
	//	operand2=ClassificationExpression)*;
	public EqualityExpressionElements getEqualityExpressionAccess() {
		return pEqualityExpression;
	}
	
	public ParserRule getEqualityExpressionRule() {
		return getEqualityExpressionAccess().getRule();
	}

	//enum EqualityOperator:
	//	equals="==" | notEquals="!=";
	public EqualityOperatorElements getEqualityOperatorAccess() {
		return unknownRuleEqualityOperator;
	}
	
	public EnumRule getEqualityOperatorRule() {
		return getEqualityOperatorAccess().getRule();
	}

	/// * LOGICAL EXPRESSIONS * / AndExpression returns Expression:
	//	EqualityExpression ({LogicalExpression.operand1=current} operator="&" operand2=EqualityExpression)*;
	public AndExpressionElements getAndExpressionAccess() {
		return pAndExpression;
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}

	//ExclusiveOrExpression returns Expression:
	//	AndExpression ({LogicalExpression.operand1=current} operator="^" operand2=AndExpression)*;
	public ExclusiveOrExpressionElements getExclusiveOrExpressionAccess() {
		return pExclusiveOrExpression;
	}
	
	public ParserRule getExclusiveOrExpressionRule() {
		return getExclusiveOrExpressionAccess().getRule();
	}

	//InclusiveOrExpression returns Expression:
	//	ExclusiveOrExpression ({LogicalExpression.operand1=current} operator="|" operand2=ExclusiveOrExpression)*;
	public InclusiveOrExpressionElements getInclusiveOrExpressionAccess() {
		return pInclusiveOrExpression;
	}
	
	public ParserRule getInclusiveOrExpressionRule() {
		return getInclusiveOrExpressionAccess().getRule();
	}

	/// * CONDITIONAL LOGICAL EXPRESSIONS * / ConditionalAndExpression returns Expression:
	//	InclusiveOrExpression ({ConditionalLogicalExpression.operand1=current} operator="&&"
	//	operand2=InclusiveOrExpression)*;
	public ConditionalAndExpressionElements getConditionalAndExpressionAccess() {
		return pConditionalAndExpression;
	}
	
	public ParserRule getConditionalAndExpressionRule() {
		return getConditionalAndExpressionAccess().getRule();
	}

	//ConditionalOrExpression returns Expression:
	//	ConditionalAndExpression ({ConditionalLogicalExpression.operand1=current} operator="||"
	//	operand2=ConditionalAndExpression)*;
	public ConditionalOrExpressionElements getConditionalOrExpressionAccess() {
		return pConditionalOrExpression;
	}
	
	public ParserRule getConditionalOrExpressionRule() {
		return getConditionalOrExpressionAccess().getRule();
	}

	/// * CONDITIONAL-TEST EXPRESSIONS * / ConditionalExpression returns Expression:
	//	ConditionalOrExpression ({ConditionalTestExpression.operand1=current} "?" operand2=Expression ":"
	//	operand3=ConditionalExpression)?;
	public ConditionalExpressionElements getConditionalExpressionAccess() {
		return pConditionalExpression;
	}
	
	public ParserRule getConditionalExpressionRule() {
		return getConditionalExpressionAccess().getRule();
	}

	/// * ASSIGNMENT EXPRESSIONS * / AssignmentExpression:
	//	leftHandSide=LeftHandSide operator=AssignmentOperator rightHandSide=Expression;
	public AssignmentExpressionElements getAssignmentExpressionAccess() {
		return pAssignmentExpression;
	}
	
	public ParserRule getAssignmentExpressionRule() {
		return getAssignmentExpressionAccess().getRule();
	}

	////  "(" LeftHandSide ")"
	//LeftHandSide:
	//	NameLeftHandSide | // ( index = Index )? | //TODO Indexing
	//	FeatureLeftHandSide;
	public LeftHandSideElements getLeftHandSideAccess() {
		return pLeftHandSide;
	}
	
	public ParserRule getLeftHandSideRule() {
		return getLeftHandSideAccess().getRule();
	}

	//NameLeftHandSide: // CHANGE: Moved the index property from LeftHandSide down to just NameLeftHandSide.
	//	expression=NameExpression index=Index?;
	public NameLeftHandSideElements getNameLeftHandSideAccess() {
		return pNameLeftHandSide;
	}
	
	public ParserRule getNameLeftHandSideRule() {
		return getNameLeftHandSideAccess().getRule();
	}

	//FeatureLeftHandSide: // CHANGE: Replaced the feature property of a FeatureLeftHandSide with expression.
	//	expression=PropertyAccessExpression;
	public FeatureLeftHandSideElements getFeatureLeftHandSideAccess() {
		return pFeatureLeftHandSide;
	}
	
	public ParserRule getFeatureLeftHandSideRule() {
		return getFeatureLeftHandSideAccess().getRule();
	}

	//enum AssignmentOperator:
	//	assign="=" | incrementAssign="+=" | decrementAssign="-=" | multiplyAssign="*=" | divisionAssign="/=" |
	//	moduloAssign="%=" | andAssign="&=" | orAssign="|=" | xorAssign="^=" | leftShiftAssign="<<=" | rightShiftAssign=">>="
	//	| tripleShiftAssign=">>>=";
	public AssignmentOperatorElements getAssignmentOperatorAccess() {
		return unknownRuleAssignmentOperator;
	}
	
	public EnumRule getAssignmentOperatorRule() {
		return getAssignmentOperatorAccess().getRule();
	}

	/// **************
	// * STATEMENTS *
	// ************** / Statement:
	//	SimpleStatement ";" | BlockStatement | IfStatement | SwitchStatement | WhileStatement | ForStatement |
	//	ForEachStatement | DoStatement | BreakStatement | ReturnStatement | ClassifyStatement | SendSignalStatement;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//SimpleStatement:
	//	LocalNameDeclarationStatement | ExpressionStatement | EmptyStatement;
	public SimpleStatementElements getSimpleStatementAccess() {
		return pSimpleStatement;
	}
	
	public ParserRule getSimpleStatementRule() {
		return getSimpleStatementAccess().getRule();
	}

	/// * BLOCK * / Block:
	//	{Block} "{" statement+=Statement* "}";
	public BlockElements getBlockAccess() {
		return pBlock;
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	/// * BLOCK STATEMENTS * / BlockStatement:
	//	Block;
	public BlockStatementElements getBlockStatementAccess() {
		return pBlockStatement;
	}
	
	public ParserRule getBlockStatementRule() {
		return getBlockStatementAccess().getRule();
	}

	/// * EMPTY STATEMENTS * / EmptyStatement:
	//	{EmptyStatement};
	public EmptyStatementElements getEmptyStatementAccess() {
		return pEmptyStatement;
	}
	
	public ParserRule getEmptyStatementRule() {
		return getEmptyStatementAccess().getRule();
	}

	//MultiplicityIndicator:
	//	"[" "]";
	public MultiplicityIndicatorElements getMultiplicityIndicatorAccess() {
		return pMultiplicityIndicator;
	}
	
	public ParserRule getMultiplicityIndicatorRule() {
		return getMultiplicityIndicatorAccess().getRule();
	}

	//VariableDeclaration returns uml::NamedElement:
	//	{Variable} type=TypeDeclaration hasMultiplicity?=MultiplicityIndicator? name=Name;
	public VariableDeclarationElements getVariableDeclarationAccess() {
		return pVariableDeclaration;
	}
	
	public ParserRule getVariableDeclarationRule() {
		return getVariableDeclarationAccess().getRule();
	}

	/// * LOCAL NAME DECLARATION STATEMENTS * / LocalNameDeclarationStatement:
	//	variable=VariableDeclaration "=" expression=InitializationExpression;
	public LocalNameDeclarationStatementElements getLocalNameDeclarationStatementAccess() {
		return pLocalNameDeclarationStatement;
	}
	
	public ParserRule getLocalNameDeclarationStatementRule() {
		return getLocalNameDeclarationStatementAccess().getRule();
	}

	//InitializationExpression returns Expression:
	//	Expression | InstanceInitializationExpression;
	public InitializationExpressionElements getInitializationExpressionAccess() {
		return pInitializationExpression;
	}
	
	public ParserRule getInitializationExpressionRule() {
		return getInitializationExpressionAccess().getRule();
	}

	//InstanceInitializationExpression returns InstanceCreationExpression:
	//	"new" tuple=Tuple;
	public InstanceInitializationExpressionElements getInstanceInitializationExpressionAccess() {
		return pInstanceInitializationExpression;
	}
	
	public ParserRule getInstanceInitializationExpressionRule() {
		return getInstanceInitializationExpressionAccess().getRule();
	}

	/// * EXPRESSION STATEMENTS * / ExpressionStatement:
	//	expression=Expression;
	public ExpressionStatementElements getExpressionStatementAccess() {
		return pExpressionStatement;
	}
	
	public ParserRule getExpressionStatementRule() {
		return getExpressionStatementAccess().getRule();
	}

	/// * IF STATEMENTS * / IfStatement:
	//	"if" nonFinalClauses+=ConcurrentClauses ("else" "if" nonFinalClauses+=ConcurrentClauses)* ("else"
	//	finalClause=Block)?;
	public IfStatementElements getIfStatementAccess() {
		return pIfStatement;
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}

	//ConcurrentClauses:
	//	clause+=NonFinalClause ("or" "if" clause+=NonFinalClause)*;
	public ConcurrentClausesElements getConcurrentClausesAccess() {
		return pConcurrentClauses;
	}
	
	public ParserRule getConcurrentClausesRule() {
		return getConcurrentClausesAccess().getRule();
	}

	//NonFinalClause:
	//	"(" condition=Expression ")" body=Block;
	public NonFinalClauseElements getNonFinalClauseAccess() {
		return pNonFinalClause;
	}
	
	public ParserRule getNonFinalClauseRule() {
		return getNonFinalClauseAccess().getRule();
	}

	/// * SWITCH STATEMENTS * / SwitchStatement:
	//	"switch" "(" expression=Expression ")" "{" nonDefaultClause+=SwitchClause* defaultClause=SwitchDefaultClause? "}";
	public SwitchStatementElements getSwitchStatementAccess() {
		return pSwitchStatement;
	}
	
	public ParserRule getSwitchStatementRule() {
		return getSwitchStatementAccess().getRule();
	}

	//SwitchClause:
	//	case+=SwitchCase case+=SwitchCase* block=NonEmptyStatementSequence;
	public SwitchClauseElements getSwitchClauseAccess() {
		return pSwitchClause;
	}
	
	public ParserRule getSwitchClauseRule() {
		return getSwitchClauseAccess().getRule();
	}

	//SwitchCase returns Expression:
	//	"case" Expression ":";
	public SwitchCaseElements getSwitchCaseAccess() {
		return pSwitchCase;
	}
	
	public ParserRule getSwitchCaseRule() {
		return getSwitchCaseAccess().getRule();
	}

	//SwitchDefaultClause returns Block:
	//	"default" ":" NonEmptyStatementSequence;
	public SwitchDefaultClauseElements getSwitchDefaultClauseAccess() {
		return pSwitchDefaultClause;
	}
	
	public ParserRule getSwitchDefaultClauseRule() {
		return getSwitchDefaultClauseAccess().getRule();
	}

	//NonEmptyStatementSequence returns Block:
	//	statement+=Statement+;
	public NonEmptyStatementSequenceElements getNonEmptyStatementSequenceAccess() {
		return pNonEmptyStatementSequence;
	}
	
	public ParserRule getNonEmptyStatementSequenceRule() {
		return getNonEmptyStatementSequenceAccess().getRule();
	}

	/// * WHILE STATEMENTS * / WhileStatement:
	//	"while" "(" condition=Expression ")" body=Block;
	public WhileStatementElements getWhileStatementAccess() {
		return pWhileStatement;
	}
	
	public ParserRule getWhileStatementRule() {
		return getWhileStatementAccess().getRule();
	}

	/// * DO STATEMENTS * / DoStatement:
	//	"do" body=Block "while" "(" condition=Expression ")" ";";
	public DoStatementElements getDoStatementAccess() {
		return pDoStatement;
	}
	
	public ParserRule getDoStatementRule() {
		return getDoStatementAccess().getRule();
	}

	/// * FOR STATEMENTS * / ForStatement:
	//	"for" "(" initialization=SimpleStatement ";" condition=Expression ";" update=SimpleStatement ")" body=Block;
	public ForStatementElements getForStatementAccess() {
		return pForStatement;
	}
	
	public ParserRule getForStatementRule() {
		return getForStatementAccess().getRule();
	}

	//ForEachStatement:
	//	"for" "(" variableDefinition=LoopVariableDefinition ")" body=Block;
	public ForEachStatementElements getForEachStatementAccess() {
		return pForEachStatement;
	}
	
	public ParserRule getForEachStatementRule() {
		return getForEachStatementAccess().getRule();
	}

	//LoopVariableDefinition returns Variable:
	//	{LoopVariable} (name=Name | type=TypeDeclaration name=Name) ":" expression=Expression;
	public LoopVariableDefinitionElements getLoopVariableDefinitionAccess() {
		return pLoopVariableDefinition;
	}
	
	public ParserRule getLoopVariableDefinitionRule() {
		return getLoopVariableDefinitionAccess().getRule();
	}

	/// * BREAK STATEMENTS * / BreakStatement:
	//	{BreakStatement} "break" ";";
	public BreakStatementElements getBreakStatementAccess() {
		return pBreakStatement;
	}
	
	public ParserRule getBreakStatementRule() {
		return getBreakStatementAccess().getRule();
	}

	/// * RETURN STATEMENTS * / ReturnStatement:
	//	{ReturnStatement} "return" expression=Expression? ";";
	public ReturnStatementElements getReturnStatementAccess() {
		return pReturnStatement;
	}
	
	public ParserRule getReturnStatementRule() {
		return getReturnStatementAccess().getRule();
	}

	/// * CLASSIFY STATEMENTS * / ClassifyStatement:
	//	"classify" expression=Expression (fromList=ClassificationFromClause toList=ClassificationToClause? |
	//	isReclassifyAll?=ReclassifyAllClause? toList=ClassificationToClause) ";";
	public ClassifyStatementElements getClassifyStatementAccess() {
		return pClassifyStatement;
	}
	
	public ParserRule getClassifyStatementRule() {
		return getClassifyStatementAccess().getRule();
	}

	//ClassificationFromClause returns QualifiedNameList:
	//	"from" QualifiedNameList;
	public ClassificationFromClauseElements getClassificationFromClauseAccess() {
		return pClassificationFromClause;
	}
	
	public ParserRule getClassificationFromClauseRule() {
		return getClassificationFromClauseAccess().getRule();
	}

	//ClassificationToClause returns QualifiedNameList:
	//	"to" QualifiedNameList;
	public ClassificationToClauseElements getClassificationToClauseAccess() {
		return pClassificationToClause;
	}
	
	public ParserRule getClassificationToClauseRule() {
		return getClassificationToClauseAccess().getRule();
	}

	//ReclassifyAllClause:
	//	"from" "*";
	public ReclassifyAllClauseElements getReclassifyAllClauseAccess() {
		return pReclassifyAllClause;
	}
	
	public ParserRule getReclassifyAllClauseRule() {
		return getReclassifyAllClauseAccess().getRule();
	}

	//QualifiedNameList:
	//	name+=QualifiedName ("," name+=QualifiedName)*;
	public QualifiedNameListElements getQualifiedNameListAccess() {
		return pQualifiedNameList;
	}
	
	public ParserRule getQualifiedNameListRule() {
		return getQualifiedNameListAccess().getRule();
	}

	/// ****************
	// * Send statement
	// ***************** / SendSignalStatement:
	//	{SendSignalStatement} "send" signal=Expression "to" target=Expression ";";
	public SendSignalStatementElements getSendSignalStatementAccess() {
		return pSendSignalStatement;
	}
	
	public ParserRule getSendSignalStatementRule() {
		return getSendSignalStatementAccess().getRule();
	}

	/// ****************
	// * Terminals
	// ***************** / terminal BOOLEAN_VALUE:
	//	"true" | "false";
	public TerminalRule getBOOLEAN_VALUERule() {
		return tBOOLEAN_VALUE;
	} 

	//terminal NATURAL_VALUE:
	//	("0" | "1".."9" ("_"? "0".."9")*) //DECIMAL 
	//	// BINARY
	//	// HEX
	//	// OCT
	//	| ("0b" | "0B") "0".."1" ("_"? "0".."1")* | ("0x" | "0X") ("0".."9" | "a".."f" | "A".."F") ("_"? ("0".."9" | "a".."f" |
	//	"A".."F"))* | "0" "_"? "0".."7" ("_"? "0".."7")*;
	public TerminalRule getNATURAL_VALUERule() {
		return tNATURAL_VALUE;
	} 

	//terminal REAL_VALUE:
	//	("0" | "1".."9" ("_"? "0".."9")*) "." "0".."9" ("_"? "0".."9")*;
	public TerminalRule getREAL_VALUERule() {
		return tREAL_VALUE;
	} 

	//terminal ID:
	//	("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return tID;
	} 

	//terminal UNRESTRICTED_NAME:
	//	"\'" ("\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getUNRESTRICTED_NAMERule() {
		return tUNRESTRICTED_NAME;
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"";
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	} 

	//terminal ML_COMMENT:
	//	"/ *" !("*" | "@")->"* /";
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	} 

	//terminal SL_COMMENT:
	//	"//" (!("@" | "\n" | "\r") !("\n" | "\r")*)? ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return tWS;
	} 
}
