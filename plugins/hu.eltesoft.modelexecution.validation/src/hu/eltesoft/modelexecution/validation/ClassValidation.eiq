package hu.eltesoft.modelexecution.validation

import "http://www.eclipse.org/uml2/5.0.0/UML"
import hu.eltesoft.modelexecution.uml.incquery.NumericValue
import hu.eltesoft.modelexecution.uml.incquery.ClassOrAssocClass
import hu.eltesoft.modelexecution.uml.incquery.Parent
import hu.eltesoft.modelexecution.uml.incquery.IsAncestor
import hu.eltesoft.modelexecution.uml.incquery.OperationOverride
import hu.eltesoft.modelexecution.uml.incquery.Attribute
import hu.eltesoft.modelexecution.uml.incquery.AttributeType
import hu.eltesoft.modelexecution.uml.incquery.Operation
import hu.eltesoft.modelexecution.uml.incquery.Reception
import hu.eltesoft.modelexecution.uml.incquery.Event
import hu.eltesoft.modelexecution.uml.incquery.Association
import hu.eltesoft.modelexecution.uml.incquery.Method

@Violation(message = "Classes must be public, there is no visibility checking", mark = { "cl" })
pattern ClassNotPublic(cl : Class) {
	find ClassOrAssocClass(cl);
	Class.visibility(cl, visibility);
	visibility != VisibilityKind::public;
}

@Violation(message = "Leaf class {cl} cannot be generalized", mark = { "spec" })
pattern LeafClassGeneralized(cl : Class, spec : Class) {
	Class.isLeaf(cl, true);
	Generalization.general(gen, cl);
	Generalization.specific(gen, spec);
}

@Violation(message = "Self generalization is not allowed", mark = { "cl" })
pattern SelfGeneralization(cl : Class) {
	Generalization.general(gen, cl);
	Generalization.specific(gen, cl);
}

@Violation(message = "Multiple direct generalization is not allowed", mark = { "spec" })
pattern DirectMultipleGeneralization(spec : Class) {
	Generalization.general(gen1, cl);
	Generalization.specific(gen1, spec);
	Generalization.general(gen2, cl);
	Generalization.specific(gen2, spec);
	gen1 != gen2;
}

@Violation(message = "Cyclic inheritance", mark = { "cl" })
pattern CyclicInheritance(cl : Class) {
	find IsAncestor(cl, other);
	find IsAncestor(other, cl);
}

@Violation(message = "Class with behavior must be active", mark = { "cl" })
pattern PassiveClassWithBehavior(cl : Class) {
	find ClassOrAssocClass(cl);
	Class.isActive(cl, false);
	Class.classifierBehavior(cl, _);
}

@Violation(message = "If state machine is owned by class it must be its classifier behavior", mark = { "beh" })
pattern ClassStateMachineOwnedBehavior(beh : StateMachine) {
	Class.ownedBehavior(cl, beh);
	neg find ClassifierBehavior(cl, beh);
}

private pattern ClassifierBehavior(cl : Class, beh : Behavior) {
	Class.classifierBehavior(cl, beh);
}

@Violation(message = "Multiple possible overrides for operation {overridden}", mark = { "cl" })
pattern AmbigousOperation(cl : Class, overridden : Operation) {
	find OperationOverride(cl, overridden, overrider1);
	find OperationOverride(cl, overridden, overrider2);
	overrider1 != overrider2;
}

@Violation(message = "Unknown element in class {cl}", mark = { "elem" })
pattern UnrecognizedElementInClass(cl : Class, elem : Element) {
	find ClassOrAssocClass(cl);
	Class.ownedElement(cl, elem);
	neg find Attribute(_, elem, _);
	neg find Operation(_, elem, _);
	neg find Reception(_, elem, _);
	neg find Method(_, _, elem);
	neg find Event(elem);
	neg find Signal(elem);
	neg find Association(elem);
	neg find Generalization(elem);
	neg find StateMachine(elem);
}

// FIXME: use declared
private pattern Signal(gen : Signal) {
	Signal(gen);
}

// FIXME: use declared
private pattern StateMachine(sm : StateMachine) {
	StateMachine(sm);
}

private pattern Generalization(gen : Generalization) {
	Generalization(gen);
}

//////////////////////////////
// generalization
//////////////////////////////

@Violation(message = "Generalization sets are not supported", mark = { "gen" })
pattern GeneralizationSet(gen : Generalization) {
	Generalization.generalizationSet(gen, _);
}

@Violation(message = "Generalizations must be substitutable", mark = { "gen" })
pattern GeneralizationNotSubstitutable(gen : Generalization) {
	Generalization.isSubstitutable(gen, flase);
}

//////////////////////////////
// association class
//////////////////////////////
@Violation(message = "Generalization of association class {ac} is not supported", mark = { "spec" })
pattern GeneralizationOfAssocClass(ac : AssociationClass, spec : Class) {
	find Parent(spec, ac);
}


//////////////////////////////
// property
//////////////////////////////
@Violation(message = "Generalization of association class {ac} is not supported", mark = { "pr" })
pattern NonDatatypeProperty(pr : Property) {
	find ClassOrAssocClass(cl);
	find AttributeType(cl, pr, ty, _, _);
	neg find DataType(ty);
}

private pattern DataType(dt : DataType) {
	DataType(dt);
}

@Violation(message = "Aggregation is not supported", mark = { "pr" })
pattern PropertyAggregation(pr : Property) {
	Property.aggregation(pr, ag);
	ag != AggregationKind::none;
}

@Violation(message = "Default value is not supported", mark = { "pr" })
pattern PropertyDefaultValue(pr : Property) {
	Property.defaultValue(pr, _);
}

@Violation(message = "Derived properties are not supported", mark = { "pr" })
pattern PropertyIsDerived(pr : Property) {
	Property.isDerived(pr, true);
}

@Violation(message = "Derived properties are not supported", mark = { "pr" })
pattern PropertyIsDerivedUnion(pr : Property) {
	Property.isDerivedUnion(pr, true);
}

@Violation(message = "ID properties are not supported", mark = { "pr" })
pattern PropertyIsID(pr : Property) {
	Property.isID(pr, true);
}

@Violation(message = "Read-only properties are not supported", mark = { "pr" })
pattern PropertyIsReadOnly(pr : Property) {
	Property.isReadOnly(pr, true);
}

@Violation(message = "Property redefinition is not supported", mark = { "pr" })
pattern PropertyRedefinedProperty(pr : Property) {
	Property.redefinedProperty(pr, _);
}

@Violation(message = "Property subsetting is not supported", mark = { "pr" })
pattern PropertySubsettedProperty(pr : Property) {
	Property.subsettedProperty(pr, _);
}

@Violation(message = "Properties must be public, there is no visibility checking", mark = { "pr" })
pattern PropertyNotPublic(pr : Property) {
	Property.visibility(pr, visibility);
	visibility != VisibilityKind::public;
}

@Violation(message = "Unrecognized element in property {pr}", mark = { "elem" })
pattern PropertyUnrecognizedElement(pr : Property, elem : Element) {
	Property.ownedElement(pr, elem);
}

@Violation(message = "Unique properties cannot have lower bound higher than 1, because they could not be default initialized", mark = { "pr" })
pattern PropertyCannotBeDefaultInitialized(pr : Property) {
	Property.isUnique(pr, true);
	Property.lowerValue(pr, low);
	find NumericValue(low, v);
	check(1 < (v as Integer));
}

//////////////////////////////
// operations
//////////////////////////////
@Violation(message = "Return type cannot have multiplicity", mark = { "param" })
pattern ReturnTypeMultiplicity(param : Parameter) {
	Operation.ownedParameter(_, param);
	Parameter.direction(param, ParameterDirectionKind::^return);
}

@Violation(message = "If the operation is not abstract it must have a method", mark = { "op" })
pattern NonAbstractOperationWithoutMethod(op : Operation) {
	Operation.isAbstract(op, false);
	neg find Method(_, op, _);
}

@Violation(message = "Abstract operation cannot have a method", mark = { "op" })
pattern AbstractOperationWithMethod(op : Operation) {
	Operation.isAbstract(op, true);
	find Method(_, op, _);
}

@Violation(message = "Parameters of the method must be the same as its specification {redefined}", 
	mark = { "op" }, post = "hu.eltesoft.modelexecution.validation.utils.ParameterValidator"
)
pattern OperationAndMethodParametersMustBeTheSame(op : Operation, method : Behavior) {
	find Method(_, op, method);
}

@Violation(message = "Parameters of the operation must be the same as the redefined operation {redefined}", 
	mark = { "op" }, post = "hu.eltesoft.modelexecution.validation.utils.ParameterValidator"
)
pattern RedefinedAndRedefiningParametersMustBeTheSame(redefined : Operation, op : Operation) {
	Operation.redefinedOperation(op, redefined);
}

@Violation(message = "Redefining operation must have the same name as the redefined", mark = { "op" })
pattern RedefiningNameDifferent(op : Operation) {
	Operation.redefinedOperation(op, redefined);
	Operation.name(op, n1);
	Operation.name(redefined, n2);
	n1 != n2;
}

@Violation(message = "Redefining operation must be in a descendant of the class of the redefined", mark = { "op" })
pattern RedefinedMustBeInAncestor(op : Operation) {
	Operation.redefinedOperation(op, redefined);
	Operation.class(op, opCls);
	Operation.class(redefined, redefinedCls);
	neg find IsAncestor(opCls, redefinedCls);
}

@Violation(message = "The redefining operation cannot be abstract", mark = { "op" })
pattern RedefiningAbstract(op : Operation) {
	Operation.redefinedOperation(op, _);
	Operation.isAbstract(op, true);
}

@Violation(message = "The redefining operation cannot be static", mark = { "op" })
pattern RedefiningStatic(op : Operation) {
	Operation.redefinedOperation(op, _);
	Operation.isStatic(op, true);
}

@Violation(message = "Cannot redefine the static operation {redefined}", mark = { "op" })
pattern RedefinedStatic(op : Operation, redefined : Operation) {
	Operation.redefinedOperation(op, redefined);
	Operation.isStatic(redefined, true);
}

@Violation(message = "Cannot redefine the leaf operation {redefined}", mark = { "op" })
pattern RedefinedLeaf(op : Operation, redefined : Operation) {
	Operation.redefinedOperation(op, redefined);
	Operation.isLeaf(redefined, true);
}

@Violation(message = "Only abstract classes can contain abstract operations", mark = { "op" })
pattern ClassContainsAbstractOperation(op : Operation) {
	Operation.isAbstract(op, true);
	Operation.class(op, cls);
	Class.isAbstract(cls, false);
}

@Violation(message = "An operation cannot be static and abstract at the same time", mark = { "op" })
pattern StaticAbstractOperation(op : Operation) {
	Operation.isAbstract(op, true);
	Operation.class(op, cls);
	Class.isAbstract(cls, false);
}

@Violation(message = "Only methods marked with the stereotype Create can have the same name as the class", 
	mark = { "op" }, post = "hu.eltesoft.modelexecution.validation.utils.CreateOperation"
)
pattern UnmarkedConstructor(op : Operation) {
	Operation.name(op, name);
	Operation.class(op, cls);
	Class.name(cls, name);
}

@Violation(message = "Only methods marked with the stereotype Destroy can be named 'destroy'", 
	mark = { "op" }, post = "hu.eltesoft.modelexecution.validation.utils.CreateOperation"
)
pattern UnmarkedDestructor(op : Operation) {
	Operation.name(op, "destroy");
}

@Violation(message = "The method of an operation must be an opaque behavior", mark = { "op" })
pattern MethodNotOpaqueBehavior(op : Operation) {
	Operation.method(op, meth);
	neg find OpaqueBehavior(meth);
}

private pattern OpaqueBehavior(beh : OpaqueBehavior) {
	OpaqueBehavior(beh);
}

@Violation(message = "Operations must be public, there is no visibility checking", mark = { "op" })
pattern OperationNotPublic(op : Operation) {
	Operation.visibility(op, visibility);
	visibility != VisibilityKind::public;
}

//////////////////////////////
// method
//////////////////////////////
@Violation(message = "The method must have rALF language implementation", mark = { "me" })
pattern MethodWithoutRalf(me : OpaqueBehavior) {
	neg find MethodRalf(me);
}

private pattern MethodRalf(me : OpaqueBehavior) {
	OpaqueBehavior.language(me, "rALF");
	OpaqueBehavior.body(me, _);
}

@Violation(message = "The method have an implementation that is not rALF", mark = { "me" })
pattern MethodWithOtherImplementation(me : OpaqueBehavior) {
	OpaqueBehavior.language(me, lang);
	lang != "rALF";
}

@Violation(message = "Method without specification", mark = { "me" })
pattern MethodWithoutSpecification(me : OpaqueBehavior) {
	neg find Method(_, _, me);
}

@Violation(message = "Method cannot have classifier behavior", mark = { "me" })
pattern MethodClassifierBehavior(me : OpaqueBehavior) {
	OpaqueBehavior.classifierBehavior(me, _);
}

@Violation(message = "Method cannot be abstract", mark = { "me" })
pattern MethodAbstract(me : OpaqueBehavior) {
	OpaqueBehavior.isAbstract(me, true);
}

@Violation(message = "Method cannot be active", mark = { "me" })
pattern MethodActive(me : OpaqueBehavior) {
	OpaqueBehavior.isActive(me, true);
}

@Violation(message = "Method cannot be reentrant", mark = { "me" })
pattern MethodReentrant(me : OpaqueBehavior) {
	OpaqueBehavior.isReentrant(me, true);
}

@Violation(message = "Operations can redefine each other, methods cannot", mark = { "me" })
pattern MethodRedefines(me : OpaqueBehavior) {
	OpaqueBehavior.redefinedBehavior(me, _);
}

@Violation(message = "Methods must be public", mark = { "me" })
pattern MethodNotPublic(me : OpaqueBehavior) {
	OpaqueBehavior.visibility(me, visibility);
	visibility != VisibilityKind::public;
}


@Violation(message = "Unrecognised element in method", mark = { "elem" })
pattern MethodElement(elem : Element) {
	OpaqueBehavior.ownedElement(_, elem);
	neg find Parameter(elem);
}

//////////////////////////////
// parameter
//////////////////////////////
private pattern Parameter(elem : Parameter) {
	Parameter(elem);
}

@Violation(message = "Parameters effect must be create", mark = { "pm" })
pattern ParameterEffect(pm : Parameter) {
	Parameter.effect(pm, ParameterEffectKind::create);
}

@Violation(message = "Exception parameters are not supported", mark = { "pm" })
pattern ParameterException(pm : Parameter) {
	Parameter.isException(pm, true);
}

@Violation(message = "Stream parameters are not supported", mark = { "pm" })
pattern ParameterStream(pm : Parameter) {
	Parameter.isStream(pm, true);
}

@Violation(message = "Parameter sets are not supported", mark = { "pm" })
pattern ParameterSet(pm : Parameter) {
	Parameter.parameterSet(pm, _);
}

@Violation(message = "Parameter visibility must be public", mark = { "pm" })
pattern ParameterNonPublic(pm : Parameter) {
	Parameter.visibility(pm, visibility);
	visibility != VisibilityKind::public;
}

@Violation(message = "Unrecognised element in parameter", mark = { "pm" })
pattern ParameterElement(elem : Element) {
	Parameter.ownedElement(_, elem);
}

//////////////////////////////
// association
//////////////////////////////
@Violation(message = "Association visibility must be public", mark = { "ac" })
pattern AssociationNonPublic(ac : Association) {
	Association.visibility(ac, visibility);
	visibility != VisibilityKind::public;
}

@Violation(message = "Association must have two ends", mark = { "ac" })
pattern AssociationMissingEnd(ac : Association) {
	neg find AssociationEnds(ac, me1, me2);
} or {
	find AssociationEnds(ac, me1, me2);
	Association.memberEnd(ac, me3);
	me1 != me3;
	me2 != me3;
}

private pattern AssociationEnds(ac : Association, me1 : Property, me2 : Property) {
	Association.memberEnd(ac, me1);
	Association.memberEnd(ac, me2);
	me1 != me2;
}

@Violation(message = "Association ends must have class type", mark = { "ac" })
pattern AssociationEndMustBeClass(ac : Association) {
	Association.memberEnd(ac, me);
	Property.type(me, t);
	neg find ClassOrAssocClass(t);
}

@Violation(message = "Association member ends must be navigable", mark = { "ac" })
pattern AssociationEndMustBeNavigable(ac : Association) {
	Association.memberEnd(ac, me);
	neg find NavigableEnd(ac, me);
}

private pattern NavigableEnd(ac, me) {
	Association.navigableOwnedEnd(ac, me);
}

@Violation(message = "Abstract associations are not supported", mark = { "ac" })
pattern AssociationAbstract(ac : Association) {
	Association.isAbstract(ac, true);
}

@Violation(message = "Derived associations are not supported", mark = { "ac" })
pattern AssociationDerived(ac : Association) {
	Association.isDerived(ac, true);
}

@Violation(message = "Associations can only contain their member ends", mark = { "pm" })
pattern AssociationElement(elem : Element) {
	neg find ClassOrAssocClass(ac);
	Association(ac);
	Association.ownedElement(_, elem);
	neg find AssociationEnds(ac, elem, _);
}