package hu.eltesoft.modelexecution.validation

import "platform:/resource/org.eclipse.uml2.uml/model/UML.ecore"
import "http://modelexecution.eltesoft.hu/xumlrt/"

import hu.eltesoft.modelexecution.uml.incquery.NumericValue
import hu.eltesoft.modelexecution.uml.incquery.ClassOrAssocClass
import hu.eltesoft.modelexecution.uml.incquery.Parent
import hu.eltesoft.modelexecution.uml.incquery.IsAncestor
import hu.eltesoft.modelexecution.uml.incquery.OperationOverride
import hu.eltesoft.modelexecution.uml.incquery.Attribute
import hu.eltesoft.modelexecution.uml.incquery.AttributeType
import hu.eltesoft.modelexecution.uml.incquery.Operation
import hu.eltesoft.modelexecution.uml.incquery.Reception
import hu.eltesoft.modelexecution.uml.incquery.Event
import hu.eltesoft.modelexecution.uml.incquery.Association
import hu.eltesoft.modelexecution.uml.incquery.Method

@Violation(message = "Classes must be public, there is no visibility checking", mark = { "cl" })
pattern ClassNotPublic(cl : Class) {
	find ClassOrAssocClass(cl);
	Class.visibility(cl, visibility);
	visibility != VisibilityKind::public;
}

@Violation(message = "Leaf class {cl} cannot be generalized", mark = { "spec" })
pattern LeafClassGeneralized(cl : Class, spec : Class) {
	Class.isLeaf(cl, true);
	Generalization.general(gen, cl);
	Generalization.specific(gen, spec);
}

@Violation(message = "Self generalization is not allowed", mark = { "cl" })
pattern SelfGeneralization(cl : Class) {
	Generalization.general(gen, cl);
	Generalization.specific(gen, cl);
}

@Violation(message = "Multiple direct generalization is not allowed", mark = { "spec" })
pattern DirectMultipleGeneralization(spec : Class) {
	Generalization.general(gen1, cl);
	Generalization.specific(gen1, spec);
	Generalization.general(gen2, cl);
	Generalization.specific(gen2, spec);
	gen1 != gen2;
}

@Violation(message = "Cyclic inheritance", mark = { "cl" })
pattern CyclicInheritance(cl : Class) {
	find IsAncestor(cl, other);
	find IsAncestor(other, cl);
}

@Violation(message = "Class with behavior must be active", mark = { "cl" })
pattern PassiveClassWithBehavior(cl : Class) {
	find ClassOrAssocClass(cl);
	Class.isActive(cl, false);
	Class.classifierBehavior(cl, _);
}

@Violation(message = "If state machine is owned by class it must be its classifier behavior", mark = { "beh" })
pattern ClassStateMachineOwnedBehavior(beh : StateMachine) {
	Class.ownedBehavior(cl, beh);
	neg find ClassifierBehavior(cl, beh);
}

private pattern ClassifierBehavior(cl : Class, beh : Behavior) {
	Class.classifierBehavior(cl, beh);
}

@Violation(message = "Multiple possible overrides for operation {overridden}", mark = { "cl" })
pattern AmbigousOperation(cl : Class, overridden : Operation) {
	find OperationOverride(cl, overridden, overrider1);
	find OperationOverride(cl, overridden, overrider2);
	overrider1 != overrider2;
}

@Violation(message = "Unknown element in class {cl}", mark = { "elem" })
pattern UnrecognizedElementInClass(cl : Class, elem : Element) {
	find ClassOrAssocClass(cl);
	Class.ownedElement(cl, elem);
	neg find Attribute(_, elem, _);
	neg find Operation(_, elem, _);
	neg find Reception(_, elem, _);
	neg find Method(_, _, elem);
	neg find Event(elem);
	neg find Signal(elem);
	neg find Association(elem);
	neg find Generalization(elem);
	neg find StateMachine(elem);
}

// FIXME: use declared
private pattern Signal(gen : Signal) {
	Signal(gen);
}

// FIXME: use declared
private pattern StateMachine(sm : StateMachine) {
	StateMachine(sm);
}

private pattern Generalization(gen : Generalization) {
	Generalization(gen);
}

//////////////////////////////
// generalization
//////////////////////////////

@Violation(message = "Generalization sets are not supported", mark = { "gen" })
pattern GeneralizationSet(gen : Generalization) {
	Generalization.generalizationSet(gen, _);
}

@Violation(message = "Generalizations must be substitutable", mark = { "gen" })
pattern GeneralizationNotSubstitutable(gen : Generalization) {
	Generalization.isSubstitutable(gen, false);
}

//////////////////////////////
// association class
//////////////////////////////
@Violation(message = "Generalization of association class {ac} is not supported", mark = { "spec" })
pattern GeneralizationOfAssocClass(ac : AssociationClass, spec : Class) {
	find Parent(spec, ac);
}


//////////////////////////////
// property
//////////////////////////////
@Violation(message = "Type of class attribute must be a data type", mark = { "pr" })
pattern NonDatatypeProperty(pr : Property) {
	find ClassOrAssocClass(cl);
	find AttributeType(cl, pr, ty, _, _);
	neg find DataType(ty);
}

private pattern DataType(dt : DataType) {
	DataType(dt);
}

@Violation(message = "Aggregation is not supported", mark = { "pr" })
pattern PropertyAggregation(pr : Property) {
	Property.aggregation(pr, ag);
	ag != AggregationKind::none;
}

@Violation(message = "Default value is not supported", mark = { "pr" })
pattern PropertyDefaultValue(pr : Property) {
	Property.defaultValue(pr, _);
}

@Violation(message = "Derived properties are not supported", mark = { "pr" })
pattern PropertyIsDerived(pr : Property) {
	Property.isDerived(pr, true);
} or {
	Property.isDerivedUnion(pr, true);
}


@Violation(message = "Composite properties are not supported", mark = { "pr" })
pattern PropertyIsComposite(pr : Property) {
	Property.isComposite(pr, true);
}

@Violation(message = "ID properties are not supported", mark = { "pr" })
pattern PropertyIsID(pr : Property) {
	Property.isID(pr, true);
}

@Violation(message = "Read-only properties are not supported", mark = { "pr" })
pattern PropertyIsReadOnly(pr : Property) {
	Property.isReadOnly(pr, true);
}

@Violation(message = "Property redefinition is not supported", mark = { "pr" })
pattern PropertyRedefinedProperty(pr : Property) {
	Property.redefinedProperty(pr, _);
}

@Violation(message = "Property subsetting is not supported", mark = { "pr" })
pattern PropertySubsettedProperty(pr : Property) {
	Property.subsettedProperty(pr, _);
}

@Violation(message = "Properties must be public, there is no visibility checking", mark = { "pr" })
pattern PropertyNotPublic(pr : Property) {
	Property.visibility(pr, visibility);
	visibility != VisibilityKind::public;
}

@Violation(message = "Unrecognized element in property {pr}", mark = { "elem" })
pattern PropertyUnrecognizedElement(pr : Property, elem : Element) {
	Property.ownedElement(pr, elem);
	neg find IsBound(pr, elem);
}

private pattern IsBound(pr : MultiplicityElement, elem : ValueSpecification) {
	MultiplicityElement.upperValue(pr, elem);
} or {
	MultiplicityElement.lowerValue(pr, elem);
}

@Violation(message = "Unique properties cannot have lower bound higher than 1, because they could not be default initialized", mark = { "pr" })
pattern PropertyCannotBeDefaultInitialized(pr : Property) {
	Property.isUnique(pr, true);
	Property.lowerValue(pr, low);
	find NumericValue(low, v);
	check(1 < (v as Integer));
}

//////////////////////////////
// operations
//////////////////////////////
@Violation(message = "Return type cannot have multiplicity", mark = { "param" })
pattern ReturnTypeMultiplicity(param : Parameter) {
	Operation.ownedParameter(_, param);
	Parameter.direction(param, ParameterDirectionKind::^return);
	Parameter.upperValue(param, high);
	find NumericValue(high, uv);
	check(uv != 1);
}

@Violation(message = "If the operation is not abstract it must have a method", mark = { "op" })
pattern NonAbstractOperationWithoutMethod(op : Operation) {
	Operation.isAbstract(op, false);
	Operation.class(op, cls);
	neg find ExternalEntity(cls, _);
	neg find Method(_, op, _);
}

@Violation(message = "Abstract operation cannot have a method", mark = { "op" })
pattern AbstractOperationWithMethod(op : Operation) {
	Operation.isAbstract(op, true);
	find Method(_, op, _);
}

@Violation(message = "Parameters of the operation must be the same as the redefined operation {redefined}", 
	mark = { "op" }, post = "hu.eltesoft.modelexecution.validation.utils.ParameterValidator"
)
pattern RedefinedAndRedefiningParametersMustBeTheSame(redefined : Operation, op : Operation) {
	Operation.redefinedOperation(op, redefined);
}

@Violation(message = "Redefining operation must have the same name as the redefined", mark = { "op" })
pattern RedefiningNameDifferent(op : Operation) {
	Operation.redefinedOperation(op, redefined);
	Operation.name(op, n1);
	Operation.name(redefined, n2);
	n1 != n2;
}

@Violation(message = "Redefining operation must be in a descendant of the class of the redefined", mark = { "op" })
pattern RedefinedMustBeInAncestor(op : Operation) {
	Operation.redefinedOperation(op, redefined);
	Operation.class(op, opCls);
	Operation.class(redefined, redefinedCls);
	neg find IsAncestor(opCls, redefinedCls);
}

@Violation(message = "The redefining operation cannot be abstract", mark = { "op" })
pattern RedefiningAbstract(op : Operation) {
	Operation.redefinedOperation(op, _);
	Operation.isAbstract(op, true);
}

@Violation(message = "The redefining operation cannot be static", mark = { "op" })
pattern RedefiningStatic(op : Operation) {
	Operation.redefinedOperation(op, _);
	Operation.isStatic(op, true);
}

@Violation(message = "Cannot redefine the static operation {redefined}", mark = { "op" })
pattern RedefinedStatic(op : Operation, redefined : Operation) {
	Operation.redefinedOperation(op, redefined);
	Operation.isStatic(redefined, true);
}

@Violation(message = "Cannot redefine the leaf operation {redefined}", mark = { "op" })
pattern RedefinedLeaf(op : Operation, redefined : Operation) {
	Operation.redefinedOperation(op, redefined);
	Operation.isLeaf(redefined, true);
}

@Violation(message = "Only abstract classes can contain abstract operations", mark = { "op" })
pattern ClassContainsAbstractOperation(op : Operation) {
	Operation.isAbstract(op, true);
	Operation.class(op, cls);
	Class.isAbstract(cls, false);
}

@Violation(message = "An operation cannot be static and abstract at the same time", mark = { "op" })
pattern StaticAbstractOperation(op : Operation) {
	Operation.isAbstract(op, true);
	Operation.class(op, cls);
	Class.isAbstract(cls, false);
}

@Violation(message = "Only methods marked with the stereotype Create can have the same name as the class", 
	mark = { "op" }, post = "hu.eltesoft.modelexecution.validation.utils.CreateOperation"
)
pattern UnmarkedConstructor(op : Operation) {
	Operation.name(op, name);
	Operation.class(op, cls);
	Class.name(cls, name);
}

@Violation(message = "Only methods marked with the stereotype Destroy can be named 'destroy'", 
	mark = { "op" }, post = "hu.eltesoft.modelexecution.validation.utils.CreateOperation"
)
pattern UnmarkedDestructor(op : Operation) {
	Operation.name(op, "destroy");
}

@Violation(message = "The method of an operation must be an opaque behavior", mark = { "op" })
pattern MethodNotOpaqueBehavior(op : Operation) {
	Operation.method(op, meth);
	neg find OpaqueBehavior(meth);
}

private pattern OpaqueBehavior(beh : OpaqueBehavior) {
	OpaqueBehavior(beh);
}

@Violation(message = "Operations must be public, there is no visibility checking", mark = { "op" })
pattern OperationNotPublic(op : Operation) {
	Operation.visibility(op, visibility);
	visibility != VisibilityKind::public;
}

//////////////////////////////
// method
//////////////////////////////
@Violation(message = "The method must have rALF language implementation", mark = { "me" })
pattern MethodWithoutRalf(me : OpaqueBehavior) {
	neg find MethodRalf(me);
}

private pattern MethodRalf(me : OpaqueBehavior) {
	OpaqueBehavior.language(me, "rALF");
	OpaqueBehavior.body(me, _);
}

@Violation(message = "The method have an implementation that is not rALF", mark = { "me" })
pattern MethodWithOtherImplementation(me : OpaqueBehavior) {
	OpaqueBehavior.language(me, lang);
	lang != "rALF";
}

@Violation(message = "Method without specification", mark = { "me" })
pattern MethodWithoutSpecification(me : OpaqueBehavior) {
	neg find Method(_, _, me);
	neg find SMEffect(me);
}

private pattern SMEffect(me : OpaqueBehavior) {
	State.entry(_, me);
} or {
	State.exit(_, me);
} or {
	Transition.effect(_, me);
}

@Violation(message = "Parameters of the method must be the same as its specification {op}", 
	mark = { "method" }, post = "hu.eltesoft.modelexecution.validation.utils.ParameterValidator"
)
pattern OperationAndMethodParametersMustBeTheSame(op : Operation, method : Behavior) {
	find Method(_, op, method);
}

@Violation(message = "Method cannot have classifier behavior", mark = { "me" })
pattern MethodClassifierBehavior(me : OpaqueBehavior) {
	OpaqueBehavior.classifierBehavior(me, _);
}

@Violation(message = "Method cannot be abstract", mark = { "me" })
pattern MethodAbstract(me : OpaqueBehavior) {
	OpaqueBehavior.isAbstract(me, true);
}

@Violation(message = "Method cannot be active", mark = { "me" })
pattern MethodActive(me : OpaqueBehavior) {
	OpaqueBehavior.isActive(me, true);
}

@Violation(message = "Method cannot be reentrant", mark = { "me" })
pattern MethodReentrant(me : OpaqueBehavior) {
	OpaqueBehavior.isReentrant(me, true);
}

@Violation(message = "Operations can redefine each other, methods cannot", mark = { "me" })
pattern MethodRedefines(me : OpaqueBehavior) {
	OpaqueBehavior.redefinedBehavior(me, _);
}

@Violation(message = "Methods must be public", mark = { "me" })
pattern MethodNotPublic(me : OpaqueBehavior) {
	OpaqueBehavior.visibility(me, visibility);
	visibility != VisibilityKind::public;
}


@Violation(message = "Unrecognised element in method", mark = { "elem" })
pattern MethodElement(elem : Element) {
	OpaqueBehavior.ownedElement(_, elem);
	neg find Parameter(elem);
}

//////////////////////////////
// parameter
//////////////////////////////
private pattern Parameter(elem : Parameter) {
	Parameter(elem);
}

@Violation(message = "Parameters effect must be create", mark = { "pm" })
pattern ParameterEffect(pm : Parameter) {
	Parameter.effect(pm, ParameterEffectKind::create);
}

@Violation(message = "Exception parameters are not supported", mark = { "pm" })
pattern ParameterException(pm : Parameter) {
	Parameter.isException(pm, true);
}

@Violation(message = "Stream parameters are not supported", mark = { "pm" })
pattern ParameterStream(pm : Parameter) {
	Parameter.isStream(pm, true);
}

@Violation(message = "Parameter sets are not supported", mark = { "pm" })
pattern ParameterSet(pm : Parameter) {
	Parameter.parameterSet(pm, _);
}

@Violation(message = "Parameter visibility must be public", mark = { "pm" })
pattern ParameterNonPublic(pm : Parameter) {
	Parameter.visibility(pm, visibility);
	visibility != VisibilityKind::public;
}

@Violation(message = "Unrecognised element in parameter", mark = { "elem" })
pattern ParameterElement(elem : Element) {
	Parameter.ownedElement(pr, elem);
	neg find IsBound(pr, elem);
}

//////////////////////////////
// association
//////////////////////////////
@Violation(message = "Association visibility must be public", mark = { "ac" })
pattern AssociationNonPublic(ac : Association) {
	Association.visibility(ac, visibility);
	visibility != VisibilityKind::public;
}

@Violation(message = "Association must have two ends", mark = { "ac" })
pattern AssociationMissingEnd(ac : Association) {
	neg find AssociationEnds(ac, me1, me2);
} or {
	find AssociationEnds(ac, me1, me2);
	Association.memberEnd(ac, me3);
	me1 != me3;
	me2 != me3;
}

private pattern AssociationEnds(ac : Association, me1 : Property, me2 : Property) {
	Association.memberEnd(ac, me1);
	Association.memberEnd(ac, me2);
	me1 != me2;
}

@Violation(message = "Association ends must have class type", mark = { "ac" })
pattern AssociationEndMustBeClass(ac : Association) {
	Association.memberEnd(ac, me);
	Property.type(me, t);
	neg find ClassOrAssocClass(t);
}

@Violation(message = "Association member ends must be navigable", mark = { "ac" })
pattern AssociationEndMustBeNavigable(ac : Association) {
	Association.memberEnd(ac, me);
	neg find NavigableEnd(ac, me);
}

private pattern NavigableEnd(ac, me) {
	Association.navigableOwnedEnd(ac, me);
}

@Violation(message = "Abstract associations are not supported", mark = { "ac" })
pattern AssociationAbstract(ac : Association) {
	Association.isAbstract(ac, true);
}

@Violation(message = "Derived associations are not supported", mark = { "ac" })
pattern AssociationDerived(ac : Association) {
	Association.isDerived(ac, true);
}

@Violation(message = "Associations can only contain their member ends", mark = { "elem" })
pattern AssociationElement(elem : Element) {
	neg find ClassOrAssocClass(ac);
	Association.ownedElement(ac, elem);
	neg find AssociationEnds(ac, elem, _);
}

//////////////////////////////
// reception
//////////////////////////////
@Violation(message = "Reception without signal", mark = { "rc" })
pattern ReceptionWithoutSignal(rc : Reception) {
	neg find ReceptionSignal(rc, _);
}

private pattern ReceptionSignal(rc : Reception, sg : Signal) {
	Reception.signal(rc, sg);
}

@Violation(message = "Abstract receptions are not supported", mark = { "rc" })
pattern ReceptionAbstract(rc : Reception) {
	Reception.isAbstract(rc, true);
}

@Violation(message = "Static receptions are not supported", mark = { "rc" })
pattern ReceptionStatic(rc : Reception) {
	Reception.isStatic(rc, true);
}

@Violation(message = "Reception methods are not supported", mark = { "rc" })
pattern ReceptionMethod(rc : Reception) {
	Reception.method(rc, _);
}

@Violation(message = "Receptions cannot raise exceptions", mark = { "rc" })
pattern ReceptionRaisedException(rc : Reception) {
	Reception.raisedException(rc, _);
}

@Violation(message = "Reception visibility must be public", mark = { "rc" })
pattern ReceptionNonPublic(rc : Reception) {
	Reception.visibility(rc, visibility);
	visibility != VisibilityKind::public;
}

@Violation(message = "Receptions can only contain parameters", mark = { "elem" })
pattern ReceptionElement(elem : Element) {
	Reception.ownedElement(_, elem);
	neg find Parameter(elem);
}

@Violation(message = "Reception parameters must be the same as their signals",
	mark = { "rc" }, post = "hu.eltesoft.modelexecution.validation.utils.ParameterValidator"
)
pattern ReceptionParameters(rc : Reception, sg : Signal) {
	find ReceptionSignal(rc, sg);
}

//////////////////////////////
// external entity
//////////////////////////////
private pattern ExternalEntity(base : Class, annot : ExternalEntity) {
	ExternalEntity.base_Class(annot, base);
}

@Violation(message = "All operations of an external entity are static", mark = { "op" })
pattern ExternalEntityOpNotStatic(op : Operation) {
	find ExternalEntity(cls, _);
	Class.ownedOperation(cls, op);
	Operation.isStatic(op, false);
}

@Violation(message = "An external entity has no attributes", mark = { "attr" })
pattern ExternalEntityAttribute(attr : Property) {
	find ExternalEntity(cl, _);
	Class.ownedAttribute(cl, attr);
}

@Violation(message = "Name of an external entity class must be a valid Java class name", mark = { "cl" })
pattern ExternalEntityNameNotValid(cl : Class) {
	find ExternalEntity(cl, _);
	Class.name(cl, name);
	check(!Helpers.validJavaIdentifierName(name));
}

@Violation(message = "Name of an operation on an external entity must be a valid Java method name", mark = { "op" })
pattern ExternalEntityOperationNameNotValid(op : Operation) {
	find ExternalEntity(cl, _);
	Class.ownedOperation(cl, op);
	Operation.name(op, name);
	check(!Helpers.validJavaIdentifierName(name));
}

@Violation(message = "Type of a parameter on an external entity operation must be a primitive type, or a class with Callable stereotype applied", mark = { "pm" })
pattern ExternalEntityOperationParameterTypeNotValid(pm : Parameter) {
	find ExternalEntityOpParam(pm);
	Parameter.type(pm, ty);
	neg find PrimitiveType(ty);
	neg find Callable(ty, _);
}

@Violation(message = "Only input parameters are accepted on an external entity operation", mark = { "pm" })
pattern ExternalEntityOperationParameterMustBeIn(pm : Parameter) {
	find ExternalEntityOpParam(pm);
	Parameter.direction(pm, dir);
	dir != ParameterDirectionKind::in;
}

@Violation(message = "Name of an operation parameter on an external entity must be a valid Java identifier", mark = { "pm" })
pattern ExternalEntityOperationParameterNameNotValid(pm : Parameter) {
	find ExternalEntityOpParam(pm);
	Parameter.name(pm, name);
	check(!Helpers.validJavaIdentifierName(name));
}

@Violation(message = "Multiplicity of an operation parameter on an external entity must be 1", mark = { "pm" })
pattern ExternalEntityOperationParameterMultiplicityNotOne(pm : Parameter) {
	find ExternalEntityOpParam(pm);
	Parameter.lowerValue(pm, lower);
	find NumericValue(lower, lv);
	check (lv != 1);
} or {
	find ExternalEntityOpParam(pm);
	Parameter.upperValue(pm, upper);
	find NumericValue(upper, uv);
	check (uv != 1);
}

@Violation(message = "External entity must be an abstract class", mark = { "cl" })
pattern ExternalEntityMustBeAbstract(cl : Class) {
	find ExternalEntity(cl, _);
	Class.isAbstract(cl, false);
}

@Violation(message = "External entity operations must return nothing or a single primitive value", mark = { "pm" })
pattern ExternalEntityOperationParameterReturnNotValid(pm : Parameter) {
	find ExternalEntityOpParam(pm);
	Parameter.direction(pm, ::^return);
	Parameter.type(pm, typ);
	neg find PrimitiveType(typ);
}

@Violation(message = "External entity cannot be the generalization of a class", mark = { "cl" })
pattern ExternalEntityGeneralization(cl : Class) {
	find ExternalEntity(cl, _);
	find Parent(cl, _);
}

@Violation(message = "External entity cannot be generalized", mark = { "cl" })
pattern ExternalEntityGeneralized(cl : Class) {
	find ExternalEntity(cl, _);
	find Parent(_, cl);
}

@Violation(message = "Two external entities cannot have the same name", mark = { "cl1", "cl2" })
pattern ExternalEntitiesWithTheSameName(cl1 : Class, cl2 : Class) {
	find ExternalEntity(cl1, _);
	find ExternalEntity(cl2, _);
	Class.name(cl1, name);
	Class.name(cl2, name);
}

private pattern PrimitiveType(ty : PrimitiveType) {
	PrimitiveType(ty);
}

private pattern ExternalEntityOpParam(pm : Parameter) {
	find ExternalEntity(cl, _);
	Class.ownedOperation(cl, op);
	Operation.ownedParameter(op, pm);
}

private pattern Callable(base : Class, annot : Callable) {
	Callable.base_Class(annot, base);
}



