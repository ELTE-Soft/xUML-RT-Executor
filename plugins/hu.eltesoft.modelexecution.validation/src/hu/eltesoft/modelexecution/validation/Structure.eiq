package hu.eltesoft.modelexecution.validation

import "http://www.eclipse.org/uml2/5.0.0/UML"
import hu.eltesoft.modelexecution.uml.incquery.Cls
import hu.eltesoft.modelexecution.uml.incquery.Event
import hu.eltesoft.modelexecution.uml.incquery.Association
import hu.eltesoft.modelexecution.uml.incquery.AssociationClass

private pattern GeneralPackagedElement(elem : Element) {
	find Package(elem);
} or {
	find Component(elem);
} or {
	find Event(elem);
} or {
	find Signal(elem);
} or {
	find Cls(elem);
} or {
	find Association(elem);
} or {
	find AssociationClass(elem);
}

//////////////////////////
// model
/////////////////////////
private pattern Model(md : Model) {
	Model(md);
}

@Violation(message = "Models can only contain components, packages, events, signals, classes, associations, package imports and profile application", mark = { "elem" })
pattern ForbiddenModelMember(md : Model, elem : Element) {
	Package.ownedElement(md, elem);
	neg find GeneralPackagedElement(elem);
	neg find PackageImport(elem);
	neg find ProfileApplication(elem);
}

@Violation(message = "Model viewpoints are not supported", mark = { "md" })
pattern ModelViewpoint(md : Model) {
	Model.viewpoint(md, _);
}

//////////////////////////
// package imports
/////////////////////////
private pattern PackageImport(pi : PackageImport) {
	PackageImport(pi);
}

@Violation(message = "Package import must reference the package to be imported", mark = { "pi" })
pattern PackageImportWithoutImportedPackage(pi : PackageImport) {
	neg find PackageImportPackage(pi, _);
}

private pattern PackageImportPackage(pi : PackageImport, imported : Package) {
	PackageImport.importedPackage(pi, imported);
}

@Violation(message = "Package imports must be public", mark = { "pi" })
pattern PackageImportNonPublic(pi : PackageImport) {
	PackageImport.visibility(pi, visibility);
	visibility != VisibilityKind::public;
}

///////////////////////
// packages
///////////////////////
private pattern Package(pk : Package) {
	Package(pk);
	neg find Model(pk);
}

@Violation(message = "Package merge is not supported", mark = { "pk" })
pattern PackageMerge(pk : Package) {
	Package.packageMerge(pk, _);
}

@Violation(message = "Template binding is not supported for packages", mark = { "pk" })
pattern PackageTemplateBinding(pk : Package) {
	Package.templateBinding(pk, _);
}

@Violation(message = "Template parameters are not supported for packages", mark = { "pk" })
pattern PackageTemplateParameter(pk : Package) {
	Package.templateParameter(pk, _);
}

@Violation(message = "Packages must be public", mark = { "pk" })
pattern PackageNonPublic(pk : Package) {
	Package.visibility(pk, visibility);
	visibility != VisibilityKind::public;
}

@Violation(message = "Packages can only contain components, packages, events, signals, associations and classes", mark = { "elem" })
pattern ForbiddenPackageMember(pk : Package, elem : Element) {
	find Package(pk);
	Package.ownedElement(pk, elem);
	neg find GeneralPackagedElement(elem);
}

///////////////////////
// components
///////////////////////
private pattern Component(cp : Component) {
	Component(cp);
}

@Violation(message = "Packages can only contain components, packages, events, signals and classes", mark = { "elem" })
pattern ForbiddenComponentMember(cp : Component, elem : Element) {
	Component.ownedElement(cp, elem);
	neg find GeneralPackagedElement(elem);
}

@Violation(message = "Components must be public", mark = { "cp" })
pattern ComponentNonPublic(cp : Component) {
	Component.visibility(cp, visibility);
	visibility != VisibilityKind::public;
}

@Violation(message = "Component classifier behaviors are not supported", mark = { "cp" })
pattern ComponentClassifierBehavior(cp : Component) {
	Component.classifierBehavior(cp, _);
}

@Violation(message = "Directly instantiated components are not supported", mark = { "cp" })
pattern ComponentDirectlyInstantiated(cp : Component) {
	Component.isIndirectlyInstantiated(cp, false);
}


///////////////////////
// events
///////////////////////
private pattern SignalEvent(ev : SignalEvent) {
	SignalEvent(ev);
}

@Violation(message = "Only signal events are supported", mark = { "ev" })
pattern EventIsNotSignalEvent(ev : Event) {
	neg find SignalEvent(ev);
}

///////////////////////
// signals
///////////////////////
private pattern Signal(sg : Signal) {
	Signal(sg);
}

///////////////////////
// profile application
///////////////////////
private pattern ProfileApplication(pa : ProfileApplication) {
	ProfileApplication(pa);
}


